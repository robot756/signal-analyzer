{"ast":null,"code":"export const processCSVData = (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText, options);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\nconst parseCSV = (csvText, options = {}) => {\n  const {\n    // Настройки парсинга CSV\n    timeColumn = 0,\n    strainColumn = 1,\n    // колонка тензосигнала\n    interferometerColumn = 3,\n    // колонка интерферометра\n    skipRows = 6650,\n    // строк для пропуска в начале\n    maxRows = 27000,\n    // максимальное количество строк для обработки\n    dataStartMarker = \"TIME,CH1,\",\n    // маркер начала данных\n\n    // Коэффициенты обработки сигналов\n    strainCoefficient = 0.00132 * 1.25,\n    interferometerOffset = 0.04,\n    // Настройки фильтрации\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    // Настройки интерферометра\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    // Порог пересечения\n    intersectionThreshold = 0.02\n  } = options;\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const strain = []; // тензометрический сигнал\n  const interferometer = []; // интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n  let dataStartIndex = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки\n    if (!line) continue;\n\n    // Автопоиск начала данных если маркер не указан\n    if (!dataStartMarker || line.includes(dataStartMarker) || dataStartMarker === \"auto\" && !isNaN(parseFloat(line.split(\",\")[0]))) {\n      dataStarted = true;\n      dataStartIndex = i;\n      if (dataStartMarker && !dataStartMarker.includes(\"auto\")) continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки\n      if (lineCount < skipRows) continue;\n      if (maxRows && lineCount > maxRows) break;\n      const fields = line.split(\",\");\n\n      // Автоопределение колонок при первом успешном парсинге\n      let actualTimeCol = timeColumn;\n      let actualStrainCol = strainColumn;\n      let actualInterfCol = interferometerColumn;\n      if (options.autoDetectColumns && i === dataStartIndex + skipRows) {\n        // Простая эвристика для автоопределения колонок\n        for (let j = 0; j < fields.length; j++) {\n          const val = parseFloat(fields[j]);\n          if (!isNaN(val)) {\n            if (Math.abs(val) < 1) actualTimeCol = j;else if (Math.abs(val) > 0.1 && Math.abs(val) < 10) actualStrainCol = j;else if (Math.abs(val) > 0.01) actualInterfCol = j;\n          }\n        }\n      }\n      if (fields.length > Math.max(actualTimeCol, actualStrainCol, actualInterfCol)) {\n        const timeVal = parseFloat(fields[actualTimeCol]);\n        const strainVal = parseFloat(fields[actualStrainCol]);\n        const interfVal = parseFloat(fields[actualInterfCol]);\n        if (!isNaN(timeVal) && !isNaN(strainVal) && !isNaN(interfVal)) {\n          t.push(timeVal);\n          strain.push(strainVal * strainCoefficient);\n          interferometer.push(interfVal + interferometerOffset);\n        }\n      }\n    }\n  }\n  console.log(`Прочитано данных: t=${t.length}, strain=${strain.length}, interferometer=${interferometer.length}`);\n\n  // Автоматическое определение параметров если нужно\n  const processedData = processInterferometerData(t, strain, interferometer, options);\n  return {\n    t,\n    strain,\n    interferometer,\n    ...processedData,\n    metadata: {\n      dataStartIndex,\n      totalLines: lineCount,\n      processedLines: t.length\n    }\n  };\n};\nconst processInterferometerData = (t, strain, interferometer, options = {}) => {\n  const {\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02,\n    autoDetectParameters = true\n  } = options;\n\n  // Автоматический анализ сигнала для определения параметров\n  let analysisParams = {};\n  if (autoDetectParameters) {\n    analysisParams = analyzeSignal(interferometer, t);\n  }\n\n  // Поиск нулевых пересечений\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interferometer);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePoints(t0, y0, minDistance, maxFilterIterations);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivative(filteredT0, interferometerConstant);\n  const intersectionPoints = findSignalIntersections(t, strain, interferometer, intersectionThreshold);\n  return {\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints,\n    analysisParams\n  };\n};\nconst analyzeSignal = (signal, time) => {\n  // Анализ амплитуды сигнала\n  const maxAmplitude = Math.max(...signal);\n  const minAmplitude = Math.min(...signal);\n  const amplitude = (maxAmplitude - minAmplitude) / 2;\n\n  // Анализ частоты (грубый)\n  let zeroCrossings = 0;\n  for (let i = 1; i < signal.length; i++) {\n    if (signal[i - 1] <= 0 && signal[i] > 0 || signal[i - 1] >= 0 && signal[i] < 0) {\n      zeroCrossings++;\n    }\n  }\n  const duration = time[time.length - 1] - time[0];\n  const estimatedFrequency = zeroCrossings / (2 * duration);\n  return {\n    amplitude,\n    estimatedFrequency,\n    maxAmplitude,\n    minAmplitude,\n    zeroCrossings\n  };\n};\nconst findZeroCrossings = (t, signal) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < signal.length; i++) {\n    const y1 = signal[i - 1];\n    const y2 = signal[i];\n\n    // Проверяем пересечение нуля\n    if (y1 <= 0 && y2 > 0 || y1 >= 0 && y2 < 0) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n\n      // Линейная интерполяция для точного определения точки пересечения\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\nconst filterClosePoints = (t0, y0, minDistance, maxIterations = 10) => {\n  if (t0.length <= 1) {\n    return {\n      filteredT0: t0,\n      filteredY0: y0\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n  for (let k = 0; k < maxIterations; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\nconst calculateDerivative = (t0, constant = 0.63 / 4 * 1e-6) => {\n  const u_interf = [];\n  const dudt_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = constant;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + constant;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\nconst findSignalIntersections = (t, signal1, signal2, threshold = 0.02) => {\n  const intersections = [];\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = signal1[i - 1] - signal2[i - 1];\n    const diffCurr = signal1[i] - signal2[i];\n    if (diffPrev <= 0 && diffCurr > 0 || diffPrev >= 0 && diffCurr < 0) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n      if (diffDelta === 0) continue;\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n      const signal1Value = signal1[i - 1] + ratio * (signal1[i] - signal1[i - 1]);\n      const signal2Value = signal2[i - 1] + ratio * (signal2[i] - signal2[i - 1]);\n      const value = (signal1Value + signal2Value) / 2;\n      if (Math.abs(value) <= threshold) {\n        intersections.push({\n          time,\n          value\n        });\n      }\n    }\n  }\n  return intersections;\n};\nexport const generateChartData = (results, chartOptions = {}) => {\n  const {\n    t,\n    strain,\n    interferometer,\n    t0,\n    dudt_interf,\n    intersectionPoints,\n    analysisParams\n  } = results;\n  const {\n    // Настройки ограничения данных\n    maxDataPoints = 2000,\n    // Настройки коррекции времени\n    timeCorrectionInterferometer = -51.5e-6,\n    timeCorrectionStrain = 50e-6,\n    // Настройки преобразования сигналов\n    strainTransformScale = -5000,\n    strainTransformOffset = 0.38,\n    // Настройки отображения\n    showOriginalSignals = true,\n    showProcessedSignals = true,\n    showIntersections = true\n  } = chartOptions;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / maxDataPoints));\n  const limitedT = [];\n  const limitedStrain = [];\n  const limitedInterferometer = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedStrain.push(strain[i]);\n    limitedInterferometer.push(interferometer[i]);\n  }\n  const chartData = {\n    original: [],\n    processed: [],\n    intersections: intersectionPoints,\n    metadata: {\n      analysisParams,\n      totalPoints: t.length,\n      displayedPoints: limitedT.length\n    }\n  };\n\n  // Оригинальные сигналы\n  if (showOriginalSignals) {\n    chartData.original.push({\n      label: \"Тензометрический сигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedStrain[idx]\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterferometer[idx]\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    });\n  }\n\n  // Обработанные сигналы\n  if (showProcessedSignals && t0 && dudt_interf) {\n    chartData.processed.push({\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time + timeCorrectionInterferometer,\n        y: dudt_interf[idx]\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    }, {\n      label: \"Преобразованный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + timeCorrectionStrain,\n        y: limitedStrain[idx] * strainTransformScale + strainTransformOffset\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    });\n  }\n\n  // Точки пересечения\n  if (showIntersections && intersectionPoints.length) {\n    const intersectionDataset = {\n      label: \"Пересечения сигналов\",\n      data: intersectionPoints.map(({\n        time,\n        value\n      }) => ({\n        x: time,\n        y: value\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 4,\n      pointBorderColor: \"#000000\",\n      pointBackgroundColor: \"rgba(0, 0, 0, 0.7)\",\n      borderWidth: 2,\n      order: 999,\n      intersectionMarker: true\n    };\n    if (showOriginalSignals) {\n      chartData.original.push(intersectionDataset);\n    }\n    if (showProcessedSignals) {\n      chartData.processed.push({\n        ...intersectionDataset,\n        order: 999\n      });\n    }\n  }\n\n  // Сохраняем исходные данные для пересчета\n  chartData.rawData = {\n    t: limitedT,\n    strain: limitedStrain,\n    interferometer: limitedInterferometer,\n    fullT: t,\n    fullStrain: strain,\n    fullInterferometer: interferometer,\n    t0,\n    dudt_interf\n  };\n  console.log(\"Данные для графиков подготовлены\", chartData.metadata);\n  return chartData;\n};\n\n// Вспомогательная функция для предпросмотра данных CSV\nexport const previewCSV = (file, linesToPreview = 10) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const lines = csvText.split('\\n').slice(0, linesToPreview + 5); // +5 для поиска заголовков\n        const preview = {\n          lines: lines.filter(line => line.trim()),\n          totalLines: csvText.split('\\n').length\n        };\n\n        // Автоопределение структуры\n        const firstDataLine = lines.find(line => {\n          const fields = line.split(',');\n          return fields.length > 1 && !isNaN(parseFloat(fields[0]));\n        });\n        if (firstDataLine) {\n          preview.estimatedStructure = {\n            columns: firstDataLine.split(',').length,\n            sampleData: firstDataLine.split(',').map(field => parseFloat(field) || field.trim())\n          };\n        }\n        resolve(preview);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};","map":{"version":3,"names":["processCSVData","file","options","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","timeColumn","strainColumn","interferometerColumn","skipRows","maxRows","dataStartMarker","strainCoefficient","interferometerOffset","minDistance","maxFilterIterations","interferometerConstant","intersectionThreshold","lines","split","t","strain","interferometer","dataStarted","lineCount","dataStartIndex","i","length","line","trim","includes","isNaN","parseFloat","fields","actualTimeCol","actualStrainCol","actualInterfCol","autoDetectColumns","j","val","Math","abs","max","timeVal","strainVal","interfVal","push","console","log","processedData","processInterferometerData","metadata","totalLines","processedLines","autoDetectParameters","analysisParams","analyzeSignal","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePoints","u_interf","dudt_interf","calculateDerivative","intersectionPoints","findSignalIntersections","signal","time","maxAmplitude","minAmplitude","min","amplitude","zeroCrossings","duration","estimatedFrequency","y1","y2","x1","x2","t_zero","maxIterations","k","newT0","newY0","constant","du_interf","dt_interf","signal1","signal2","threshold","intersections","diffPrev","diffCurr","t1","t2","diffDelta","ratio","signal1Value","signal2Value","value","generateChartData","chartOptions","maxDataPoints","timeCorrectionInterferometer","timeCorrectionStrain","strainTransformScale","strainTransformOffset","showOriginalSignals","showProcessedSignals","showIntersections","step","floor","limitedT","limitedStrain","limitedInterferometer","chartData","original","processed","totalPoints","displayedPoints","label","data","map","idx","x","y","borderColor","backgroundColor","borderWidth","tension","pointRadius","showLine","intersectionDataset","pointStyle","pointBorderColor","pointBackgroundColor","order","intersectionMarker","rawData","fullT","fullStrain","fullInterferometer","previewCSV","linesToPreview","slice","preview","filter","firstDataLine","find","estimatedStructure","columns","sampleData","field"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["export const processCSVData = (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText, options);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\nconst parseCSV = (csvText, options = {}) => {\n  const {\n    // Настройки парсинга CSV\n    timeColumn = 0,\n    strainColumn = 1,    // колонка тензосигнала\n    interferometerColumn = 3, // колонка интерферометра\n    skipRows = 6650,     // строк для пропуска в начале\n    maxRows = 27000,     // максимальное количество строк для обработки\n    dataStartMarker = \"TIME,CH1,\", // маркер начала данных\n    \n    // Коэффициенты обработки сигналов\n    strainCoefficient = 0.00132 * 1.25,\n    interferometerOffset = 0.04,\n    \n    // Настройки фильтрации\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    \n    // Настройки интерферометра\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    \n    // Порог пересечения\n    intersectionThreshold = 0.02\n  } = options;\n\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const strain = []; // тензометрический сигнал\n  const interferometer = []; // интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n  let dataStartIndex = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки\n    if (!line) continue;\n\n    // Автопоиск начала данных если маркер не указан\n    if (!dataStartMarker || line.includes(dataStartMarker) || \n        (dataStartMarker === \"auto\" && !isNaN(parseFloat(line.split(\",\")[0])))) {\n      dataStarted = true;\n      dataStartIndex = i;\n      if (dataStartMarker && !dataStartMarker.includes(\"auto\")) continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки\n      if (lineCount < skipRows) continue;\n      if (maxRows && lineCount > maxRows) break;\n\n      const fields = line.split(\",\");\n      \n      // Автоопределение колонок при первом успешном парсинге\n      let actualTimeCol = timeColumn;\n      let actualStrainCol = strainColumn;\n      let actualInterfCol = interferometerColumn;\n      \n      if (options.autoDetectColumns && i === dataStartIndex + skipRows) {\n        // Простая эвристика для автоопределения колонок\n        for (let j = 0; j < fields.length; j++) {\n          const val = parseFloat(fields[j]);\n          if (!isNaN(val)) {\n            if (Math.abs(val) < 1) actualTimeCol = j;\n            else if (Math.abs(val) > 0.1 && Math.abs(val) < 10) actualStrainCol = j;\n            else if (Math.abs(val) > 0.01) actualInterfCol = j;\n          }\n        }\n      }\n\n      if (fields.length > Math.max(actualTimeCol, actualStrainCol, actualInterfCol)) {\n        const timeVal = parseFloat(fields[actualTimeCol]);\n        const strainVal = parseFloat(fields[actualStrainCol]);\n        const interfVal = parseFloat(fields[actualInterfCol]);\n\n        if (!isNaN(timeVal) && !isNaN(strainVal) && !isNaN(interfVal)) {\n          t.push(timeVal);\n          strain.push(strainVal * strainCoefficient);\n          interferometer.push(interfVal + interferometerOffset);\n        }\n      }\n    }\n  }\n\n  console.log(\n    `Прочитано данных: t=${t.length}, strain=${strain.length}, interferometer=${interferometer.length}`\n  );\n\n  // Автоматическое определение параметров если нужно\n  const processedData = processInterferometerData(t, strain, interferometer, options);\n  \n  return {\n    t,\n    strain,\n    interferometer,\n    ...processedData,\n    metadata: {\n      dataStartIndex,\n      totalLines: lineCount,\n      processedLines: t.length\n    }\n  };\n};\n\nconst processInterferometerData = (t, strain, interferometer, options = {}) => {\n  const {\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02,\n    autoDetectParameters = true\n  } = options;\n\n  // Автоматический анализ сигнала для определения параметров\n  let analysisParams = {};\n  if (autoDetectParameters) {\n    analysisParams = analyzeSignal(interferometer, t);\n  }\n\n  // Поиск нулевых пересечений\n  const { t0, y0 } = findZeroCrossings(t, interferometer);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const { filteredT0, filteredY0 } = filterClosePoints(t0, y0, minDistance, maxFilterIterations);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const { u_interf, dudt_interf } = calculateDerivative(filteredT0, interferometerConstant);\n  const intersectionPoints = findSignalIntersections(t, strain, interferometer, intersectionThreshold);\n\n  return {\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints,\n    analysisParams\n  };\n};\n\nconst analyzeSignal = (signal, time) => {\n  // Анализ амплитуды сигнала\n  const maxAmplitude = Math.max(...signal);\n  const minAmplitude = Math.min(...signal);\n  const amplitude = (maxAmplitude - minAmplitude) / 2;\n  \n  // Анализ частоты (грубый)\n  let zeroCrossings = 0;\n  for (let i = 1; i < signal.length; i++) {\n    if ((signal[i-1] <= 0 && signal[i] > 0) || (signal[i-1] >= 0 && signal[i] < 0)) {\n      zeroCrossings++;\n    }\n  }\n  const duration = time[time.length - 1] - time[0];\n  const estimatedFrequency = zeroCrossings / (2 * duration);\n  \n  return {\n    amplitude,\n    estimatedFrequency,\n    maxAmplitude,\n    minAmplitude,\n    zeroCrossings\n  };\n};\n\nconst findZeroCrossings = (t, signal) => {\n  const t0 = [];\n  const y0 = [];\n\n  for (let i = 1; i < signal.length; i++) {\n    const y1 = signal[i - 1];\n    const y2 = signal[i];\n\n    // Проверяем пересечение нуля\n    if ((y1 <= 0 && y2 > 0) || (y1 >= 0 && y2 < 0)) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n\n      // Линейная интерполяция для точного определения точки пересечения\n      if (y2 !== y1) {\n        const t_zero = x1 - (y1 * (x2 - x1)) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n\n  return { t0, y0 };\n};\n\nconst filterClosePoints = (t0, y0, minDistance, maxIterations = 10) => {\n  if (t0.length <= 1) {\n    return { filteredT0: t0, filteredY0: y0 };\n  }\n\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  for (let k = 0; k < maxIterations; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    if (newT0.length === filteredT0.length) break;\n\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n\n  return { filteredT0, filteredY0 };\n};\n\nconst calculateDerivative = (t0, constant = 0.63 / 4 * 1e-6) => {\n  const u_interf = [];\n  const dudt_interf = [];\n\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = constant;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + constant;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n\n  return { u_interf, dudt_interf };\n};\n\nconst findSignalIntersections = (t, signal1, signal2, threshold = 0.02) => {\n  const intersections = [];\n\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = signal1[i - 1] - signal2[i - 1];\n    const diffCurr = signal1[i] - signal2[i];\n\n    if ((diffPrev <= 0 && diffCurr > 0) || (diffPrev >= 0 && diffCurr < 0)) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n\n      if (diffDelta === 0) continue;\n\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n\n      const signal1Value = signal1[i - 1] + ratio * (signal1[i] - signal1[i - 1]);\n      const signal2Value = signal2[i - 1] + ratio * (signal2[i] - signal2[i - 1]);\n\n      const value = (signal1Value + signal2Value) / 2;\n\n      if (Math.abs(value) <= threshold) {\n        intersections.push({ time, value });\n      }\n    }\n  }\n\n  return intersections;\n};\n\nexport const generateChartData = (results, chartOptions = {}) => {\n  const { \n    t, \n    strain, \n    interferometer, \n    t0, \n    dudt_interf, \n    intersectionPoints,\n    analysisParams \n  } = results;\n\n  const {\n    // Настройки ограничения данных\n    maxDataPoints = 2000,\n    \n    // Настройки коррекции времени\n    timeCorrectionInterferometer = -51.5e-6,\n    timeCorrectionStrain = 50e-6,\n    \n    // Настройки преобразования сигналов\n    strainTransformScale = -5000,\n    strainTransformOffset = 0.38,\n    \n    // Настройки отображения\n    showOriginalSignals = true,\n    showProcessedSignals = true,\n    showIntersections = true\n  } = chartOptions;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / maxDataPoints));\n\n  const limitedT = [];\n  const limitedStrain = [];\n  const limitedInterferometer = [];\n\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedStrain.push(strain[i]);\n    limitedInterferometer.push(interferometer[i]);\n  }\n\n  const chartData = {\n    original: [],\n    processed: [],\n    intersections: intersectionPoints,\n    metadata: {\n      analysisParams,\n      totalPoints: t.length,\n      displayedPoints: limitedT.length\n    }\n  };\n\n  // Оригинальные сигналы\n  if (showOriginalSignals) {\n    chartData.original.push(\n      {\n        label: \"Тензометрический сигнал\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedStrain[idx] })),\n        borderColor: \"rgb(255, 99, 132)\",\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n      {\n        label: \"Интерферометрический сигнал\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterferometer[idx] })),\n        borderColor: \"rgb(54, 162, 235)\",\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      }\n    );\n  }\n\n  // Обработанные сигналы\n  if (showProcessedSignals && t0 && dudt_interf) {\n    chartData.processed.push(\n      {\n        label: \"Производная интерферометрического сигнала\",\n        data: t0.map((time, idx) => ({\n          x: time + timeCorrectionInterferometer,\n          y: dudt_interf[idx],\n        })),\n        borderColor: \"rgb(75, 192, 192)\",\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n        borderWidth: 2,\n        pointRadius: 2,\n        showLine: true,\n      },\n      {\n        label: \"Преобразованный тензосигнал\",\n        data: limitedT.map((time, idx) => ({\n          x: time + timeCorrectionStrain,\n          y: limitedStrain[idx] * strainTransformScale + strainTransformOffset,\n        })),\n        borderColor: \"rgb(153, 102, 255)\",\n        backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      }\n    );\n  }\n\n  // Точки пересечения\n  if (showIntersections && intersectionPoints.length) {\n    const intersectionDataset = {\n      label: \"Пересечения сигналов\",\n      data: intersectionPoints.map(({ time, value }) => ({\n        x: time,\n        y: value,\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 4,\n      pointBorderColor: \"#000000\",\n      pointBackgroundColor: \"rgba(0, 0, 0, 0.7)\",\n      borderWidth: 2,\n      order: 999,\n      intersectionMarker: true,\n    };\n\n    if (showOriginalSignals) {\n      chartData.original.push(intersectionDataset);\n    }\n    if (showProcessedSignals) {\n      chartData.processed.push({...intersectionDataset, order: 999});\n    }\n  }\n\n  // Сохраняем исходные данные для пересчета\n  chartData.rawData = {\n    t: limitedT,\n    strain: limitedStrain,\n    interferometer: limitedInterferometer,\n    fullT: t,\n    fullStrain: strain,\n    fullInterferometer: interferometer,\n    t0,\n    dudt_interf,\n  };\n\n  console.log(\"Данные для графиков подготовлены\", chartData.metadata);\n\n  return chartData;\n};\n\n// Вспомогательная функция для предпросмотра данных CSV\nexport const previewCSV = (file, linesToPreview = 10) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const lines = csvText.split('\\n').slice(0, linesToPreview + 5); // +5 для поиска заголовков\n        const preview = {\n          lines: lines.filter(line => line.trim()),\n          totalLines: csvText.split('\\n').length\n        };\n        \n        // Автоопределение структуры\n        const firstDataLine = lines.find(line => {\n          const fields = line.split(',');\n          return fields.length > 1 && !isNaN(parseFloat(fields[0]));\n        });\n        \n        if (firstDataLine) {\n          preview.estimatedStructure = {\n            columns: firstDataLine.split(',').length,\n            sampleData: firstDataLine.split(',').map(field => parseFloat(field) || field.trim())\n          };\n        }\n        \n        resolve(preview);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    \n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}