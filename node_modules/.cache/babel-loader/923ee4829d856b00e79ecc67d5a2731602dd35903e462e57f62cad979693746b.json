{"ast":null,"code":"export const processCSVData = (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText, options);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\nconst parseCSV = (csvText, options = {}) => {\n  const {\n    timeColumn = 0,\n    strainColumn = 1,\n    interferometerColumn = 3,\n    skipRows = 6650,\n    maxRows = 27000,\n    dataStartMarker = \"TIME,CH1,\",\n    strainCoefficient = 0.00132 * 1.25,\n    interferometerOffset = 0.04,\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02\n  } = options;\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const strain = [];\n  const interferometer = [];\n  let dataStarted = false;\n  let lineCount = 0;\n  let dataStartIndex = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    if (!dataStartMarker || line.includes(dataStartMarker) || dataStartMarker === \"auto\" && !isNaN(parseFloat(line.split(\",\")[0]))) {\n      dataStarted = true;\n      dataStartIndex = i;\n      if (dataStartMarker && !dataStartMarker.includes(\"auto\")) continue;\n    }\n    if (dataStarted) {\n      lineCount++;\n      if (lineCount < skipRows) continue;\n      if (maxRows && lineCount > maxRows) break;\n      const fields = line.split(\",\");\n      let actualTimeCol = timeColumn;\n      let actualStrainCol = strainColumn;\n      let actualInterfCol = interferometerColumn;\n      if (options.autoDetectColumns && i === dataStartIndex + skipRows) {\n        for (let j = 0; j < fields.length; j++) {\n          const val = parseFloat(fields[j]);\n          if (!isNaN(val)) {\n            if (Math.abs(val) < 1) actualTimeCol = j;else if (Math.abs(val) > 0.1 && Math.abs(val) < 10) actualStrainCol = j;else if (Math.abs(val) > 0.01) actualInterfCol = j;\n          }\n        }\n      }\n      if (fields.length > Math.max(actualTimeCol, actualStrainCol, actualInterfCol)) {\n        const timeVal = parseFloat(fields[actualTimeCol]);\n        const strainVal = parseFloat(fields[actualStrainCol]);\n        const interfVal = parseFloat(fields[actualInterfCol]);\n        if (!isNaN(timeVal) && !isNaN(strainVal) && !isNaN(interfVal)) {\n          t.push(timeVal);\n          strain.push(strainVal * strainCoefficient);\n          interferometer.push(interfVal + interferometerOffset);\n        }\n      }\n    }\n  }\n  console.log(`Прочитано данных: t=${t.length}, strain=${strain.length}, interferometer=${interferometer.length}`);\n\n  // Защита от пустых данных\n  if (t.length === 0) {\n    throw new Error(\"Не удалось извлечь данные из файла\");\n  }\n  const processedData = processInterferometerData(t, strain, interferometer, options);\n  return {\n    t,\n    strain,\n    interferometer,\n    ...processedData,\n    metadata: {\n      dataStartIndex,\n      totalLines: lineCount,\n      processedLines: t.length\n    }\n  };\n};\nconst processInterferometerData = (t, strain, interferometer, options = {}) => {\n  const {\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02,\n    autoDetectParameters = true\n  } = options;\n\n  // Инициализация значений по умолчанию\n  let t0 = [];\n  let y0 = [];\n  let u_interf = [];\n  let dudt_interf = [];\n  let intersectionPoints = [];\n  let analysisParams = {};\n  try {\n    if (autoDetectParameters) {\n      analysisParams = analyzeSignal(interferometer, t);\n    }\n\n    // Поиск нулевых пересечений\n    const zeroCrossingsResult = findZeroCrossings(t, interferometer);\n    t0 = zeroCrossingsResult.t0 || [];\n    y0 = zeroCrossingsResult.y0 || [];\n    console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n    // Фильтрация близких точек\n    const filteredResult = filterClosePoints(t0, y0, minDistance, maxFilterIterations);\n    const filteredT0 = filteredResult.filteredT0 || [];\n    const filteredY0 = filteredResult.filteredY0 || [];\n    console.log(`После фильтрации: ${filteredT0.length}`);\n\n    // Расчет производной\n    const derivativeResult = calculateDerivative(filteredT0, interferometerConstant);\n    u_interf = derivativeResult.u_interf || [];\n    dudt_interf = derivativeResult.dudt_interf || [];\n\n    // Поиск пересечений\n    intersectionPoints = findSignalIntersections(t, strain, interferometer, intersectionThreshold) || [];\n  } catch (error) {\n    console.error(\"Ошибка при обработке данных интерферометра:\", error);\n  }\n  return {\n    t0: filteredT0 || [],\n    y0: filteredY0 || [],\n    u_interf: u_interf || [],\n    dudt_interf: dudt_interf || [],\n    intersectionPoints: intersectionPoints || [],\n    analysisParams\n  };\n};\nconst analyzeSignal = (signal, time) => {\n  if (!signal || signal.length === 0) return {};\n  try {\n    const maxAmplitude = Math.max(...signal);\n    const minAmplitude = Math.min(...signal);\n    const amplitude = (maxAmplitude - minAmplitude) / 2;\n    let zeroCrossings = 0;\n    for (let i = 1; i < signal.length; i++) {\n      if (signal[i - 1] <= 0 && signal[i] > 0 || signal[i - 1] >= 0 && signal[i] < 0) {\n        zeroCrossings++;\n      }\n    }\n    const duration = time[time.length - 1] - time[0];\n    const estimatedFrequency = duration > 0 ? zeroCrossings / (2 * duration) : 0;\n    return {\n      amplitude,\n      estimatedFrequency,\n      maxAmplitude,\n      minAmplitude,\n      zeroCrossings\n    };\n  } catch (error) {\n    console.error(\"Ошибка при анализе сигнала:\", error);\n    return {};\n  }\n};\nconst findZeroCrossings = (t, signal) => {\n  const t0 = [];\n  const y0 = [];\n  if (!t || !signal || t.length !== signal.length) {\n    return {\n      t0,\n      y0\n    };\n  }\n  for (let i = 1; i < signal.length; i++) {\n    const y1 = signal[i - 1];\n    const y2 = signal[i];\n    if (y1 <= 0 && y2 > 0 || y1 >= 0 && y2 < 0) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\nconst filterClosePoints = (t0, y0, minDistance, maxIterations = 10) => {\n  if (!t0 || !y0 || t0.length <= 1) {\n    return {\n      filteredT0: t0 || [],\n      filteredY0: y0 || []\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n  for (let k = 0; k < maxIterations; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\nconst calculateDerivative = (t0, constant = 0.63 / 4 * 1e-6) => {\n  const u_interf = [];\n  const dudt_interf = [];\n  if (!t0 || t0.length === 0) {\n    return {\n      u_interf,\n      dudt_interf\n    };\n  }\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = constant;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + constant;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\nconst findSignalIntersections = (t, signal1, signal2, threshold = 0.02) => {\n  const intersections = [];\n  if (!t || !signal1 || !signal2 || t.length !== signal1.length || t.length !== signal2.length) {\n    return intersections;\n  }\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = signal1[i - 1] - signal2[i - 1];\n    const diffCurr = signal1[i] - signal2[i];\n    if (diffPrev <= 0 && diffCurr > 0 || diffPrev >= 0 && diffCurr < 0) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n      if (diffDelta === 0) continue;\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n      const signal1Value = signal1[i - 1] + ratio * (signal1[i] - signal1[i - 1]);\n      const signal2Value = signal2[i - 1] + ratio * (signal2[i] - signal2[i - 1]);\n      const value = (signal1Value + signal2Value) / 2;\n      if (Math.abs(value) <= threshold) {\n        intersections.push({\n          time,\n          value\n        });\n      }\n    }\n  }\n  return intersections;\n};\nexport const generateChartData = (results, chartOptions = {}) => {\n  // Защита от undefined results\n  if (!results) {\n    console.error(\"Results are undefined\");\n    return getEmptyChartData();\n  }\n  const {\n    t = [],\n    strain = [],\n    interferometer = [],\n    t0 = [],\n    dudt_interf = [],\n    intersectionPoints = [],\n    analysisParams = {}\n  } = results;\n  const {\n    maxDataPoints = 2000,\n    timeCorrectionInterferometer = -51.5e-6,\n    timeCorrectionStrain = 50e-6,\n    strainTransformScale = -5000,\n    strainTransformOffset = 0.38,\n    showOriginalSignals = true,\n    showProcessedSignals = true,\n    showIntersections = true\n  } = chartOptions;\n\n  // Защита от пустых данных\n  if (t.length === 0) {\n    return getEmptyChartData();\n  }\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / maxDataPoints));\n  const limitedT = [];\n  const limitedStrain = [];\n  const limitedInterferometer = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedStrain.push(strain[i]);\n    limitedInterferometer.push(interferometer[i]);\n  }\n  const chartData = {\n    original: [],\n    processed: [],\n    intersections: intersectionPoints,\n    metadata: {\n      analysisParams,\n      totalPoints: t.length,\n      displayedPoints: limitedT.length\n    },\n    rawData: {\n      t: limitedT,\n      strain: limitedStrain,\n      interferometer: limitedInterferometer,\n      fullT: t,\n      fullStrain: strain,\n      fullInterferometer: interferometer,\n      t0,\n      dudt_interf\n    }\n  };\n\n  // Оригинальные сигналы - с защитой от пустых данных\n  if (showOriginalSignals && limitedT.length > 0) {\n    chartData.original.push({\n      label: \"Тензометрический сигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedStrain[idx] || 0\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterferometer[idx] || 0\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    });\n  }\n\n  // Обработанные сигналы - с защитой от пустых данных\n  if (showProcessedSignals && t0.length > 0 && dudt_interf.length > 0) {\n    chartData.processed.push({\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time + timeCorrectionInterferometer,\n        y: dudt_interf[idx] || 0\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    });\n  }\n\n  // Преобразованный тензосигнал\n  if (showProcessedSignals && limitedT.length > 0) {\n    chartData.processed.push({\n      label: \"Преобразованный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + timeCorrectionStrain,\n        y: (limitedStrain[idx] || 0) * strainTransformScale + strainTransformOffset\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    });\n  }\n\n  // Точки пересечения - с защитой\n  if (showIntersections && intersectionPoints && intersectionPoints.length > 0) {\n    const intersectionDataset = {\n      label: \"Пересечения сигналов\",\n      data: intersectionPoints.map(point => ({\n        x: (point === null || point === void 0 ? void 0 : point.time) || 0,\n        y: (point === null || point === void 0 ? void 0 : point.value) || 0\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 4,\n      pointBorderColor: \"#000000\",\n      pointBackgroundColor: \"rgba(0, 0, 0, 0.7)\",\n      borderWidth: 2,\n      order: 999,\n      intersectionMarker: true\n    };\n    if (showOriginalSignals) {\n      chartData.original.push(intersectionDataset);\n    }\n    if (showProcessedSignals) {\n      chartData.processed.push({\n        ...intersectionDataset,\n        order: 999\n      });\n    }\n  }\n  console.log(\"Данные для графиков подготовлены\", chartData.metadata);\n  return chartData;\n};\n\n// Функция для возврата пустых данных при ошибках\nconst getEmptyChartData = () => {\n  return {\n    original: [],\n    processed: [],\n    intersections: [],\n    metadata: {\n      analysisParams: {},\n      totalPoints: 0,\n      displayedPoints: 0\n    },\n    rawData: {\n      t: [],\n      strain: [],\n      interferometer: [],\n      fullT: [],\n      fullStrain: [],\n      fullInterferometer: [],\n      t0: [],\n      dudt_interf: []\n    }\n  };\n};\nexport const previewCSV = (file, linesToPreview = 10) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const lines = csvText.split('\\n').slice(0, linesToPreview + 5);\n        const preview = {\n          lines: lines.filter(line => line.trim()),\n          totalLines: csvText.split('\\n').length\n        };\n        const firstDataLine = lines.find(line => {\n          const fields = line.split(',');\n          return fields.length > 1 && !isNaN(parseFloat(fields[0]));\n        });\n        if (firstDataLine) {\n          preview.estimatedStructure = {\n            columns: firstDataLine.split(',').length,\n            sampleData: firstDataLine.split(',').map(field => parseFloat(field) || field.trim())\n          };\n        }\n        resolve(preview);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};","map":{"version":3,"names":["processCSVData","file","options","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","timeColumn","strainColumn","interferometerColumn","skipRows","maxRows","dataStartMarker","strainCoefficient","interferometerOffset","minDistance","maxFilterIterations","interferometerConstant","intersectionThreshold","lines","split","t","strain","interferometer","dataStarted","lineCount","dataStartIndex","i","length","line","trim","includes","isNaN","parseFloat","fields","actualTimeCol","actualStrainCol","actualInterfCol","autoDetectColumns","j","val","Math","abs","max","timeVal","strainVal","interfVal","push","console","log","processedData","processInterferometerData","metadata","totalLines","processedLines","autoDetectParameters","t0","y0","u_interf","dudt_interf","intersectionPoints","analysisParams","analyzeSignal","zeroCrossingsResult","findZeroCrossings","filteredResult","filterClosePoints","filteredT0","filteredY0","derivativeResult","calculateDerivative","findSignalIntersections","signal","time","maxAmplitude","minAmplitude","min","amplitude","zeroCrossings","duration","estimatedFrequency","y1","y2","x1","x2","t_zero","maxIterations","k","newT0","newY0","constant","du_interf","dt_interf","signal1","signal2","threshold","intersections","diffPrev","diffCurr","t1","t2","diffDelta","ratio","signal1Value","signal2Value","value","generateChartData","chartOptions","getEmptyChartData","maxDataPoints","timeCorrectionInterferometer","timeCorrectionStrain","strainTransformScale","strainTransformOffset","showOriginalSignals","showProcessedSignals","showIntersections","step","floor","limitedT","limitedStrain","limitedInterferometer","chartData","original","processed","totalPoints","displayedPoints","rawData","fullT","fullStrain","fullInterferometer","label","data","map","idx","x","y","borderColor","backgroundColor","borderWidth","tension","pointRadius","showLine","intersectionDataset","point","pointStyle","pointBorderColor","pointBackgroundColor","order","intersectionMarker","previewCSV","linesToPreview","slice","preview","filter","firstDataLine","find","estimatedStructure","columns","sampleData","field"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["export const processCSVData = (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText, options);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\nconst parseCSV = (csvText, options = {}) => {\n  const {\n    timeColumn = 0,\n    strainColumn = 1,\n    interferometerColumn = 3,\n    skipRows = 6650,\n    maxRows = 27000,\n    dataStartMarker = \"TIME,CH1,\",\n    strainCoefficient = 0.00132 * 1.25,\n    interferometerOffset = 0.04,\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02\n  } = options;\n\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const strain = [];\n  const interferometer = [];\n\n  let dataStarted = false;\n  let lineCount = 0;\n  let dataStartIndex = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n\n    if (!dataStartMarker || line.includes(dataStartMarker) || \n        (dataStartMarker === \"auto\" && !isNaN(parseFloat(line.split(\",\")[0])))) {\n      dataStarted = true;\n      dataStartIndex = i;\n      if (dataStartMarker && !dataStartMarker.includes(\"auto\")) continue;\n    }\n\n    if (dataStarted) {\n      lineCount++;\n      if (lineCount < skipRows) continue;\n      if (maxRows && lineCount > maxRows) break;\n\n      const fields = line.split(\",\");\n      \n      let actualTimeCol = timeColumn;\n      let actualStrainCol = strainColumn;\n      let actualInterfCol = interferometerColumn;\n      \n      if (options.autoDetectColumns && i === dataStartIndex + skipRows) {\n        for (let j = 0; j < fields.length; j++) {\n          const val = parseFloat(fields[j]);\n          if (!isNaN(val)) {\n            if (Math.abs(val) < 1) actualTimeCol = j;\n            else if (Math.abs(val) > 0.1 && Math.abs(val) < 10) actualStrainCol = j;\n            else if (Math.abs(val) > 0.01) actualInterfCol = j;\n          }\n        }\n      }\n\n      if (fields.length > Math.max(actualTimeCol, actualStrainCol, actualInterfCol)) {\n        const timeVal = parseFloat(fields[actualTimeCol]);\n        const strainVal = parseFloat(fields[actualStrainCol]);\n        const interfVal = parseFloat(fields[actualInterfCol]);\n\n        if (!isNaN(timeVal) && !isNaN(strainVal) && !isNaN(interfVal)) {\n          t.push(timeVal);\n          strain.push(strainVal * strainCoefficient);\n          interferometer.push(interfVal + interferometerOffset);\n        }\n      }\n    }\n  }\n\n  console.log(\n    `Прочитано данных: t=${t.length}, strain=${strain.length}, interferometer=${interferometer.length}`\n  );\n\n  // Защита от пустых данных\n  if (t.length === 0) {\n    throw new Error(\"Не удалось извлечь данные из файла\");\n  }\n\n  const processedData = processInterferometerData(t, strain, interferometer, options);\n  \n  return {\n    t,\n    strain,\n    interferometer,\n    ...processedData,\n    metadata: {\n      dataStartIndex,\n      totalLines: lineCount,\n      processedLines: t.length\n    }\n  };\n};\n\nconst processInterferometerData = (t, strain, interferometer, options = {}) => {\n  const {\n    minDistance = 100e-9,\n    maxFilterIterations = 10,\n    interferometerConstant = 0.63 / 4 * 1e-6,\n    intersectionThreshold = 0.02,\n    autoDetectParameters = true\n  } = options;\n\n  // Инициализация значений по умолчанию\n  let t0 = [];\n  let y0 = [];\n  let u_interf = [];\n  let dudt_interf = [];\n  let intersectionPoints = [];\n  let analysisParams = {};\n\n  try {\n    if (autoDetectParameters) {\n      analysisParams = analyzeSignal(interferometer, t);\n    }\n\n    // Поиск нулевых пересечений\n    const zeroCrossingsResult = findZeroCrossings(t, interferometer);\n    t0 = zeroCrossingsResult.t0 || [];\n    y0 = zeroCrossingsResult.y0 || [];\n    console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n    // Фильтрация близких точек\n    const filteredResult = filterClosePoints(t0, y0, minDistance, maxFilterIterations);\n    const filteredT0 = filteredResult.filteredT0 || [];\n    const filteredY0 = filteredResult.filteredY0 || [];\n    console.log(`После фильтрации: ${filteredT0.length}`);\n\n    // Расчет производной\n    const derivativeResult = calculateDerivative(filteredT0, interferometerConstant);\n    u_interf = derivativeResult.u_interf || [];\n    dudt_interf = derivativeResult.dudt_interf || [];\n\n    // Поиск пересечений\n    intersectionPoints = findSignalIntersections(t, strain, interferometer, intersectionThreshold) || [];\n\n  } catch (error) {\n    console.error(\"Ошибка при обработке данных интерферометра:\", error);\n  }\n\n  return {\n    t0: filteredT0 || [],\n    y0: filteredY0 || [],\n    u_interf: u_interf || [],\n    dudt_interf: dudt_interf || [],\n    intersectionPoints: intersectionPoints || [],\n    analysisParams\n  };\n};\n\nconst analyzeSignal = (signal, time) => {\n  if (!signal || signal.length === 0) return {};\n  \n  try {\n    const maxAmplitude = Math.max(...signal);\n    const minAmplitude = Math.min(...signal);\n    const amplitude = (maxAmplitude - minAmplitude) / 2;\n    \n    let zeroCrossings = 0;\n    for (let i = 1; i < signal.length; i++) {\n      if ((signal[i-1] <= 0 && signal[i] > 0) || (signal[i-1] >= 0 && signal[i] < 0)) {\n        zeroCrossings++;\n      }\n    }\n    const duration = time[time.length - 1] - time[0];\n    const estimatedFrequency = duration > 0 ? zeroCrossings / (2 * duration) : 0;\n    \n    return {\n      amplitude,\n      estimatedFrequency,\n      maxAmplitude,\n      minAmplitude,\n      zeroCrossings\n    };\n  } catch (error) {\n    console.error(\"Ошибка при анализе сигнала:\", error);\n    return {};\n  }\n};\n\nconst findZeroCrossings = (t, signal) => {\n  const t0 = [];\n  const y0 = [];\n\n  if (!t || !signal || t.length !== signal.length) {\n    return { t0, y0 };\n  }\n\n  for (let i = 1; i < signal.length; i++) {\n    const y1 = signal[i - 1];\n    const y2 = signal[i];\n\n    if ((y1 <= 0 && y2 > 0) || (y1 >= 0 && y2 < 0)) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n\n      if (y2 !== y1) {\n        const t_zero = x1 - (y1 * (x2 - x1)) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n\n  return { t0, y0 };\n};\n\nconst filterClosePoints = (t0, y0, minDistance, maxIterations = 10) => {\n  if (!t0 || !y0 || t0.length <= 1) {\n    return { filteredT0: t0 || [], filteredY0: y0 || [] };\n  }\n\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  for (let k = 0; k < maxIterations; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    if (newT0.length === filteredT0.length) break;\n\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n\n  return { filteredT0, filteredY0 };\n};\n\nconst calculateDerivative = (t0, constant = 0.63 / 4 * 1e-6) => {\n  const u_interf = [];\n  const dudt_interf = [];\n\n  if (!t0 || t0.length === 0) {\n    return { u_interf, dudt_interf };\n  }\n\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = constant;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + constant;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n\n  return { u_interf, dudt_interf };\n};\n\nconst findSignalIntersections = (t, signal1, signal2, threshold = 0.02) => {\n  const intersections = [];\n\n  if (!t || !signal1 || !signal2 || t.length !== signal1.length || t.length !== signal2.length) {\n    return intersections;\n  }\n\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = signal1[i - 1] - signal2[i - 1];\n    const diffCurr = signal1[i] - signal2[i];\n\n    if ((diffPrev <= 0 && diffCurr > 0) || (diffPrev >= 0 && diffCurr < 0)) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n\n      if (diffDelta === 0) continue;\n\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n\n      const signal1Value = signal1[i - 1] + ratio * (signal1[i] - signal1[i - 1]);\n      const signal2Value = signal2[i - 1] + ratio * (signal2[i] - signal2[i - 1]);\n\n      const value = (signal1Value + signal2Value) / 2;\n\n      if (Math.abs(value) <= threshold) {\n        intersections.push({ time, value });\n      }\n    }\n  }\n\n  return intersections;\n};\n\nexport const generateChartData = (results, chartOptions = {}) => {\n  // Защита от undefined results\n  if (!results) {\n    console.error(\"Results are undefined\");\n    return getEmptyChartData();\n  }\n\n  const { \n    t = [], \n    strain = [], \n    interferometer = [], \n    t0 = [], \n    dudt_interf = [], \n    intersectionPoints = [],\n    analysisParams = {} \n  } = results;\n\n  const {\n    maxDataPoints = 2000,\n    timeCorrectionInterferometer = -51.5e-6,\n    timeCorrectionStrain = 50e-6,\n    strainTransformScale = -5000,\n    strainTransformOffset = 0.38,\n    showOriginalSignals = true,\n    showProcessedSignals = true,\n    showIntersections = true\n  } = chartOptions;\n\n  // Защита от пустых данных\n  if (t.length === 0) {\n    return getEmptyChartData();\n  }\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / maxDataPoints));\n\n  const limitedT = [];\n  const limitedStrain = [];\n  const limitedInterferometer = [];\n\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedStrain.push(strain[i]);\n    limitedInterferometer.push(interferometer[i]);\n  }\n\n  const chartData = {\n    original: [],\n    processed: [],\n    intersections: intersectionPoints,\n    metadata: {\n      analysisParams,\n      totalPoints: t.length,\n      displayedPoints: limitedT.length\n    },\n    rawData: {\n      t: limitedT,\n      strain: limitedStrain,\n      interferometer: limitedInterferometer,\n      fullT: t,\n      fullStrain: strain,\n      fullInterferometer: interferometer,\n      t0,\n      dudt_interf,\n    }\n  };\n\n  // Оригинальные сигналы - с защитой от пустых данных\n  if (showOriginalSignals && limitedT.length > 0) {\n    chartData.original.push(\n      {\n        label: \"Тензометрический сигнал\",\n        data: limitedT.map((time, idx) => ({ \n          x: time, \n          y: limitedStrain[idx] || 0 \n        })),\n        borderColor: \"rgb(255, 99, 132)\",\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n      {\n        label: \"Интерферометрический сигнал\",\n        data: limitedT.map((time, idx) => ({ \n          x: time, \n          y: limitedInterferometer[idx] || 0 \n        })),\n        borderColor: \"rgb(54, 162, 235)\",\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      }\n    );\n  }\n\n  // Обработанные сигналы - с защитой от пустых данных\n  if (showProcessedSignals && t0.length > 0 && dudt_interf.length > 0) {\n    chartData.processed.push(\n      {\n        label: \"Производная интерферометрического сигнала\",\n        data: t0.map((time, idx) => ({\n          x: time + timeCorrectionInterferometer,\n          y: dudt_interf[idx] || 0,\n        })),\n        borderColor: \"rgb(75, 192, 192)\",\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n        borderWidth: 2,\n        pointRadius: 2,\n        showLine: true,\n      }\n    );\n  }\n\n  // Преобразованный тензосигнал\n  if (showProcessedSignals && limitedT.length > 0) {\n    chartData.processed.push({\n      label: \"Преобразованный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + timeCorrectionStrain,\n        y: (limitedStrain[idx] || 0) * strainTransformScale + strainTransformOffset,\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1,\n    });\n  }\n\n  // Точки пересечения - с защитой\n  if (showIntersections && intersectionPoints && intersectionPoints.length > 0) {\n    const intersectionDataset = {\n      label: \"Пересечения сигналов\",\n      data: intersectionPoints.map((point) => ({\n        x: point?.time || 0,\n        y: point?.value || 0,\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 4,\n      pointBorderColor: \"#000000\",\n      pointBackgroundColor: \"rgba(0, 0, 0, 0.7)\",\n      borderWidth: 2,\n      order: 999,\n      intersectionMarker: true,\n    };\n\n    if (showOriginalSignals) {\n      chartData.original.push(intersectionDataset);\n    }\n    if (showProcessedSignals) {\n      chartData.processed.push({...intersectionDataset, order: 999});\n    }\n  }\n\n  console.log(\"Данные для графиков подготовлены\", chartData.metadata);\n\n  return chartData;\n};\n\n// Функция для возврата пустых данных при ошибках\nconst getEmptyChartData = () => {\n  return {\n    original: [],\n    processed: [],\n    intersections: [],\n    metadata: {\n      analysisParams: {},\n      totalPoints: 0,\n      displayedPoints: 0\n    },\n    rawData: {\n      t: [],\n      strain: [],\n      interferometer: [],\n      fullT: [],\n      fullStrain: [],\n      fullInterferometer: [],\n      t0: [],\n      dudt_interf: [],\n    }\n  };\n};\n\nexport const previewCSV = (file, linesToPreview = 10) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const lines = csvText.split('\\n').slice(0, linesToPreview + 5);\n        const preview = {\n          lines: lines.filter(line => line.trim()),\n          totalLines: csvText.split('\\n').length\n        };\n        \n        const firstDataLine = lines.find(line => {\n          const fields = line.split(',');\n          return fields.length > 1 && !isNaN(parseFloat(fields[0]));\n        });\n        \n        if (firstDataLine) {\n          preview.estimatedStructure = {\n            columns: firstDataLine.split(',').length,\n            sampleData: firstDataLine.split(',').map(field => parseFloat(field) || field.trim())\n          };\n        }\n        \n        resolve(preview);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    \n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}