{"ast":null,"code":"export const processCSVData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\nconst parseCSV = csvText => {\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = []; // CH1 - тензометрический сигнал\n  const interf = []; // CH3 - интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки и заголовки\n    if (!line) continue;\n\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\n      if (lineCount < 6650) continue;\n      if (lineCount > 27000) break;\n      const fields = line.split(\",\");\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]); // TIME\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\n\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          // Добавляем смещение как в оригинале: +0.04\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n  console.log(`Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`);\n  console.log(\"Первые значения:\", {\n    t: t.slice(0, 5),\n    tenz: tenz.slice(0, 5),\n    interf: interf.slice(0, 5)\n  });\n\n  // Поиск нулевых пересечений\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interf);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePoints(t0, y0, 100e-9);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivative(filteredT0);\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interf);\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints\n  };\n};\nconst findZeroCrossings = (t, interf) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n\n    // Проверяем пересечение нуля\n    if (y1 <= 0 && y2 > 0 || y1 >= 0 && y2 < 0) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n\n      // Линейная интерполяция для точного определения точки пересечения\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (t0.length <= 1) {\n    return {\n      filteredT0: t0,\n      filteredY0: y0\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  // Многократная фильтрация (k < 10 как в оригинале)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\nconst calculateDerivative = t0 => {\n  const u_interf = [];\n  const dudt_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\nconst findSignalIntersectionsAtZero = (t, tenz, interf, yThreshold = 0.02) => {\n  const intersections = [];\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = tenz[i - 1] - interf[i - 1];\n    const diffCurr = tenz[i] - interf[i];\n    if (diffPrev <= 0 && diffCurr > 0 || diffPrev >= 0 && diffCurr < 0) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n      if (diffDelta === 0) continue;\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n      const tenzValue = tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\n      const interfValue = interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\n\n      // среднее (они почти равны)\n      const value = (tenzValue + interfValue) / 2;\n      if (Math.abs(value) <= yThreshold) {\n        intersections.push({\n          time,\n          value\n        });\n      }\n    }\n  }\n  return intersections;\n};\nexport const generateChartData = results => {\n  const {\n    t,\n    tenz,\n    interf,\n    t0,\n    dudt_interf,\n    intersectionPoints\n  } = results;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / 2000));\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // Подготавливаем данные для графиков\n  const chartData = {\n    original: [{\n      label: \"Тензометрический сигнал (CH1)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedTenz[idx]\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал (CH3)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterf[idx]\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }],\n    processed: [{\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time - 51.5e-6,\n        // коррекция времени\n        y: dudt_interf[idx]\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    }, {\n      label: \"Скорректированный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + 50e-6,\n        // коррекция времени\n        y: -limitedTenz[idx] * 5000 + 0.38 // преобразование\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }]\n  };\n  if (intersectionPoints.length) {\n    chartData.original.push({\n      label: \"Пересечения при Y=0\",\n      data: intersectionPoints.map(({\n        time,\n        value\n      }) => ({\n        x: time,\n        y: value\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 0,\n      pointHoverRadius: 0,\n      borderWidth: 0,\n      order: 99,\n      z: 50,\n      intersectionMarker: true,\n      markerSize: 4,\n      markerColor: \"#000000\",\n      markerAlpha: 0.7,\n      markerLineWidth: 2\n    });\n  }\n  chartData.intersections = intersectionPoints;\n\n  // Сохраняем исходные данные для пересчета пересечений\n  chartData.rawData = {\n    t,\n    tenz,\n    interf\n  };\n  console.log(\"Данные для графиков подготовлены\");\n  return chartData;\n};","map":{"version":3,"names":["processCSVData","file","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","lines","split","t","tenz","interf","dataStarted","lineCount","i","length","line","trim","startsWith","fields","timeVal","parseFloat","ch1Val","ch3Val","isNaN","push","console","log","slice","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePoints","u_interf","dudt_interf","calculateDerivative","intersectionPoints","findSignalIntersectionsAtZero","y1","y2","x1","x2","t_zero","minDistance","k","newT0","newY0","du_interf","dt_interf","yThreshold","intersections","diffPrev","diffCurr","t1","t2","diffDelta","ratio","time","tenzValue","interfValue","value","Math","abs","generateChartData","step","max","floor","limitedT","limitedTenz","limitedInterf","chartData","original","label","data","map","idx","x","y","borderColor","backgroundColor","borderWidth","tension","processed","pointRadius","showLine","pointStyle","pointHoverRadius","order","z","intersectionMarker","markerSize","markerColor","markerAlpha","markerLineWidth","rawData"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["export const processCSVData = (file) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n\r\n    reader.onload = (e) => {\r\n      try {\r\n        const csvText = e.target.result;\r\n        const results = parseCSV(csvText);\r\n        resolve(results);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n\r\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\r\n    reader.readAsText(file);\r\n  });\r\n};\r\n\r\nconst parseCSV = (csvText) => {\r\n  const lines = csvText.split(\"\\n\");\r\n  const t = [];\r\n  const tenz = []; // CH1 - тензометрический сигнал\r\n  const interf = []; // CH3 - интерферометрический сигнал\r\n\r\n  let dataStarted = false;\r\n  let lineCount = 0;\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i].trim();\r\n\r\n    // Пропускаем пустые строки и заголовки\r\n    if (!line) continue;\r\n\r\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\r\n    if (line.startsWith(\"TIME,CH1,\")) {\r\n      dataStarted = true;\r\n      continue;\r\n    }\r\n\r\n    // Если нашли начало данных, начинаем парсить\r\n    if (dataStarted) {\r\n      lineCount++;\r\n\r\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\r\n      if (lineCount < 6650) continue;\r\n      if (lineCount > 27000) break;\r\n\r\n      const fields = line.split(\",\");\r\n\r\n      if (fields.length >= 5) {\r\n        const timeVal = parseFloat(fields[0]); // TIME\r\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\r\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\r\n\r\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\r\n          t.push(timeVal);\r\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\r\n          tenz.push(ch1Val * 0.00132 * 1.25);\r\n          // Добавляем смещение как в оригинале: +0.04\r\n          interf.push(ch3Val + 0.04);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(\r\n    `Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`\r\n  );\r\n  console.log(\"Первые значения:\", {\r\n    t: t.slice(0, 5),\r\n    tenz: tenz.slice(0, 5),\r\n    interf: interf.slice(0, 5),\r\n  });\r\n\r\n  // Поиск нулевых пересечений\r\n  const { t0, y0 } = findZeroCrossings(t, interf);\r\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\r\n\r\n  // Фильтрация близких точек\r\n  const { filteredT0, filteredY0 } = filterClosePoints(t0, y0, 100e-9);\r\n  console.log(`После фильтрации: ${filteredT0.length}`);\r\n\r\n  // Расчет производной\r\n  const { u_interf, dudt_interf } = calculateDerivative(filteredT0);\r\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interf);\r\n\r\n  return {\r\n    t,\r\n    tenz,\r\n    interf,\r\n    t0: filteredT0,\r\n    y0: filteredY0,\r\n    u_interf,\r\n    dudt_interf,\r\n    intersectionPoints,\r\n  };\r\n};\r\n\r\nconst findZeroCrossings = (t, interf) => {\r\n  const t0 = [];\r\n  const y0 = [];\r\n\r\n  for (let i = 1; i < interf.length; i++) {\r\n    const y1 = interf[i - 1];\r\n    const y2 = interf[i];\r\n\r\n    // Проверяем пересечение нуля\r\n    if ((y1 <= 0 && y2 > 0) || (y1 >= 0 && y2 < 0)) {\r\n      const x1 = t[i - 1];\r\n      const x2 = t[i];\r\n\r\n      // Линейная интерполяция для точного определения точки пересечения\r\n      if (y2 !== y1) {\r\n        const t_zero = x1 - (y1 * (x2 - x1)) / (y2 - y1);\r\n        t0.push(t_zero);\r\n        y0.push(0);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { t0, y0 };\r\n};\r\n\r\nconst filterClosePoints = (t0, y0, minDistance) => {\r\n  if (t0.length <= 1) {\r\n    return { filteredT0: t0, filteredY0: y0 };\r\n  }\r\n\r\n  let filteredT0 = [...t0];\r\n  let filteredY0 = [...y0];\r\n\r\n  // Многократная фильтрация (k < 10 как в оригинале)\r\n  for (let k = 0; k < 10; k++) {\r\n    const newT0 = [filteredT0[0]];\r\n    const newY0 = [filteredY0[0]];\r\n\r\n    for (let i = 1; i < filteredT0.length; i++) {\r\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\r\n        newT0.push(filteredT0[i]);\r\n        newY0.push(filteredY0[i]);\r\n      }\r\n    }\r\n\r\n    // Если количество точек не изменилось, выходим\r\n    if (newT0.length === filteredT0.length) break;\r\n\r\n    filteredT0 = newT0;\r\n    filteredY0 = newY0;\r\n  }\r\n\r\n  return { filteredT0, filteredY0 };\r\n};\r\n\r\nconst calculateDerivative = (t0) => {\r\n  const u_interf = [];\r\n  const dudt_interf = [];\r\n\r\n  for (let i = 0; i < t0.length; i++) {\r\n    if (i === 0) {\r\n      u_interf[i] = (0.63 / 4) * 1e-6;\r\n      dudt_interf[i] = 0;\r\n    } else {\r\n      u_interf[i] = u_interf[i - 1] + (0.63 / 4) * 1e-6;\r\n      const du_interf = u_interf[i] - u_interf[i - 1];\r\n      const dt_interf = t0[i] - t0[i - 1];\r\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\r\n    }\r\n  }\r\n\r\n  return { u_interf, dudt_interf };\r\n};\r\n\r\nconst findSignalIntersectionsAtZero = (\r\n  t,\r\n  tenz,\r\n  interf,\r\n  yThreshold = 0.02\r\n) => {\r\n  const intersections = [];\r\n\r\n  for (let i = 1; i < t.length; i++) {\r\n    const diffPrev = tenz[i - 1] - interf[i - 1];\r\n    const diffCurr = tenz[i] - interf[i];\r\n\r\n    if ((diffPrev <= 0 && diffCurr > 0) || (diffPrev >= 0 && diffCurr < 0)) {\r\n      const t1 = t[i - 1];\r\n      const t2 = t[i];\r\n      const diffDelta = diffCurr - diffPrev;\r\n\r\n      if (diffDelta === 0) continue;\r\n\r\n      const ratio = -diffPrev / diffDelta;\r\n      const time = t1 + ratio * (t2 - t1);\r\n\r\n      const tenzValue =\r\n        tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\r\n      const interfValue =\r\n        interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\r\n\r\n      // среднее (они почти равны)\r\n      const value = (tenzValue + interfValue) / 2;\r\n\r\n      if (Math.abs(value) <= yThreshold) {\r\n        intersections.push({ time, value });\r\n      }\r\n    }\r\n  }\r\n\r\n  return intersections;\r\n};\r\n\r\nexport const generateChartData = (results) => {\r\n  const { t, tenz, interf, t0, dudt_interf, intersectionPoints } = results;\r\n\r\n  // Ограничиваем количество точек для производительности\r\n  const step = Math.max(1, Math.floor(t.length / 2000));\r\n\r\n  const limitedT = [];\r\n  const limitedTenz = [];\r\n  const limitedInterf = [];\r\n\r\n  for (let i = 0; i < t.length; i += step) {\r\n    limitedT.push(t[i]);\r\n    limitedTenz.push(tenz[i]);\r\n    limitedInterf.push(interf[i]);\r\n  }\r\n\r\n  // Подготавливаем данные для графиков\r\n  const chartData = {\r\n    original: [\r\n      {\r\n        label: \"Тензометрический сигнал (CH1)\",\r\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedTenz[idx] })),\r\n        borderColor: \"rgb(255, 99, 132)\",\r\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n      {\r\n        label: \"Интерферометрический сигнал (CH3)\",\r\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterf[idx] })),\r\n        borderColor: \"rgb(54, 162, 235)\",\r\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n    ],\r\n    processed: [\r\n      {\r\n        label: \"Производная интерферометрического сигнала\",\r\n        data: t0.map((time, idx) => ({\r\n          x: time - 51.5e-6, // коррекция времени\r\n          y: dudt_interf[idx],\r\n        })),\r\n        borderColor: \"rgb(75, 192, 192)\",\r\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\r\n        borderWidth: 2,\r\n        pointRadius: 2,\r\n        showLine: true,\r\n      },\r\n      {\r\n        label: \"Скорректированный тензосигнал\",\r\n        data: limitedT.map((time, idx) => ({\r\n          x: time + 50e-6, // коррекция времени\r\n          y: -limitedTenz[idx] * 5000 + 0.38, // преобразование\r\n        })),\r\n        borderColor: \"rgb(153, 102, 255)\",\r\n        backgroundColor: \"rgba(153, 102, 255, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n    ],\r\n  };\r\n\r\n  if (intersectionPoints.length) {\r\n    chartData.original.push({\r\n      label: \"Пересечения при Y=0\",\r\n      data: intersectionPoints.map(({ time, value }) => ({\r\n        x: time,\r\n        y: value,\r\n      })),\r\n      showLine: false,\r\n      pointStyle: \"crossRot\",\r\n      pointRadius: 0,\r\n      pointHoverRadius: 0,\r\n      borderWidth: 0,\r\n      order: 99,\r\n      z: 50,\r\n      intersectionMarker: true,\r\n      markerSize: 4,\r\n      markerColor: \"#000000\",\r\n      markerAlpha: 0.7,\r\n      markerLineWidth: 2,\r\n    });\r\n  }\r\n\r\n  chartData.intersections = intersectionPoints;\r\n  \r\n  // Сохраняем исходные данные для пересчета пересечений\r\n  chartData.rawData = {\r\n    t,\r\n    tenz,\r\n    interf,\r\n  };\r\n\r\n  console.log(\"Данные для графиков подготовлены\");\r\n\r\n  return chartData;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}