{"ast":null,"code":"// -------------------- CSV обработка --------------------\nexport const processCSVData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\n// -------------------- Утилиты для матриц --------------------\nconst transpose = M => M[0].map((_, i) => M.map(row => row[i]));\nconst multiplyMatrices = (A, B) => {\n  const aRows = A.length,\n    aCols = A[0].length,\n    bCols = B[0].length;\n  const C = Array.from({\n    length: aRows\n  }, () => Array(bCols).fill(0));\n  for (let i = 0; i < aRows; i++) {\n    for (let k = 0; k < aCols; k++) {\n      const v = A[i][k];\n      for (let j = 0; j < bCols; j++) {\n        C[i][j] += v * B[k][j];\n      }\n    }\n  }\n  return C;\n};\nconst invertMatrix = m => {\n  const n = m.length;\n  const A = m.map((row, i) => row.concat(Array.from({\n    length: n\n  }, (_, j) => i === j ? 1 : 0)));\n  for (let i = 0; i < n; i++) {\n    let maxRow = i;\n    for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;\n    if (Math.abs(A[maxRow][i]) < 1e-15) throw new Error(\"Матрица вырождена, невозможно инвертировать\");\n    if (maxRow !== i) [A[i], A[maxRow]] = [A[maxRow], A[i]];\n    const diag = A[i][i];\n    for (let j = 0; j < 2 * n; j++) A[i][j] /= diag;\n    for (let k = 0; k < n; k++) {\n      if (k === i) continue;\n      const factor = A[k][i];\n      for (let j = 0; j < 2 * n; j++) A[k][j] -= factor * A[i][j];\n    }\n  }\n  return A.map(row => row.slice(n));\n};\n\n// -------------------- Savitzky–Golay фильтр --------------------\nconst savitzkyGolay = (data, windowSize = 31, polyOrder = 3) => {\n  if (!Array.isArray(data) || data.length === 0) return [];\n  windowSize = Math.max(3, Math.floor(windowSize));\n  if (windowSize % 2 === 0) windowSize += 1;\n  polyOrder = Math.max(1, Math.floor(polyOrder));\n  if (polyOrder >= windowSize) polyOrder = windowSize - 1;\n  const n = data.length;\n  if (n <= windowSize) {\n    const out = new Array(n).fill(0);\n    const half = Math.floor(windowSize / 2);\n    for (let i = 0; i < n; i++) {\n      let sum = 0,\n        cnt = 0;\n      for (let j = i - half; j <= i + half; j++) {\n        const idx = Math.min(n - 1, Math.max(0, j));\n        sum += data[idx];\n        cnt++;\n      }\n      out[i] = sum / cnt;\n    }\n    return out;\n  }\n  const half = Math.floor(windowSize / 2);\n  const A = [];\n  for (let i = -half; i <= half; i++) {\n    const row = [];\n    for (let p = 0; p <= polyOrder; p++) row.push(Math.pow(i, p));\n    A.push(row);\n  }\n  const AT = transpose(A);\n  const ATA = multiplyMatrices(AT, A);\n  let invATA;\n  try {\n    invATA = invertMatrix(ATA);\n  } catch {\n    return data.slice();\n  }\n  const ATAinvAT = multiplyMatrices(invATA, AT);\n  const coeffs = ATAinvAT[0];\n  const out = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    let acc = 0;\n    for (let j = -half; j <= half; j++) {\n      let idx = i + j;\n      if (idx < 0) idx = 0;\n      if (idx >= n) idx = n - 1;\n      acc += data[idx] * coeffs[j + half];\n    }\n    out[i] = acc;\n  }\n  return out;\n};\n\n// -------------------- Baseline removal --------------------\nconst removeBaseline = (arr, N = 2000) => {\n  if (!Array.isArray(arr) || arr.length === 0) return [];\n  const count = Math.min(arr.length, N);\n  const avg = arr.slice(0, count).reduce((s, v) => s + v, 0) / count;\n  return arr.map(v => v - avg);\n};\n\n// -------------------- CSV парсинг (ИСПРАВЛЕННЫЙ по логике Octave) --------------------\nconst parseCSV = (csvText, options = {}) => {\n  const skipStart = options.skipStart || 6650;\n  const skipEnd = options.skipEnd || 27000;\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = [];\n  const interf = [];\n  let dataStarted = false;\n  let lineCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n    if (!dataStarted) continue;\n    lineCount++;\n    if (lineCount < skipStart) continue;\n    if (lineCount > skipEnd) break;\n    const fields = line.split(\",\");\n    if (fields.length >= 5) {\n      const timeVal = parseFloat(fields[0]);\n      const ch1Val = parseFloat(fields[1]);\n      const ch3Val = parseFloat(fields[3]);\n      if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n        t.push(timeVal);\n        tenz.push(ch1Val * 0.00132 * 1.25);\n        interf.push(ch3Val + 0.04);\n      }\n    }\n  }\n\n  // Находим нулевые пересечения как в Octave коде\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interf);\n\n  // Фильтруем близкие точки (аналогично Octave циклу)\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePointsMultiplePasses(t0, y0, 100e-9);\n\n  // Вычисляем производную по нулевым пересечениям (как в Octave)\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivativeFromZeroCrossings(filteredT0);\n\n  // Обработанный тензосигнал (как в Octave)\n  const processedTenz = processTenzSignal(t, tenz);\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    processedTenz,\n    t0_shifted: filteredT0.map(val => val - 51.5e-6),\n    // t0-51.5e-6\n    tenz_shifted_scaled: processedTenz // -tenz*5000+0.38\n  };\n};\n\n// -------------------- Нулевые пересечения (аналогично zerocrossing в Octave) --------------------\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1],\n      y2 = interf[i],\n      x1 = t[i - 1],\n      x2 = t[i];\n    if (Math.abs(y1) < eps) {\n      t0.push(x1);\n      y0.push(0);\n      continue;\n    }\n    if (Math.abs(y2) < eps) {\n      t0.push(x2);\n      y0.push(0);\n      continue;\n    }\n    if (y1 * y2 < 0) {\n      const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n      t0.push(t_zero);\n      y0.push(0);\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\n\n// -------------------- Фильтрация близких точек (многопроходная как в Octave) --------------------\nconst filterClosePointsMultiplePasses = (t0, y0, minDistance) => {\n  if (!Array.isArray(t0) || t0.length <= 1) return {\n    filteredT0: t0 || [],\n    filteredY0: y0 || []\n  };\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  // Многопроходная фильтрация (аналогично Octave циклу while)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\n\n// -------------------- Вычисление производной по нулевым пересечениям (как в Octave) --------------------\nconst calculateDerivativeFromZeroCrossings = t0 => {\n  const u_interf = [];\n  const dudt_interf = [];\n  const dt_interf = [];\n  const du_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n      dt_interf[i] = 0;\n      du_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      du_interf[i] = u_interf[i] - u_interf[i - 1];\n      dt_interf[i] = t0[i] - t0[i - 1];\n      dudt_interf[i] = du_interf[i] / dt_interf[i];\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf,\n    dt_interf,\n    du_interf\n  };\n};\n\n// -------------------- Обработка тензосигнала (как в Octave) --------------------\nconst processTenzSignal = (t, tenz) => {\n  const startIdx = 2000;\n  const endIdx = t.length - 12700;\n  const step = 10;\n  const t0_out = [];\n  const tenz_out = [];\n  let k = 0;\n  for (let i = startIdx; i < endIdx; i += step) {\n    t0_out[k] = t[i] - t[startIdx];\n    // -(-tenz(i,1)*5000+0.47)*sqrt(71e9*2770)\n    tenz_out[k] = -(-tenz[i] * 5000 + 0.47) * Math.sqrt(71e9 * 2770);\n    k++;\n  }\n  return tenz_out;\n};\n\n// -------------------- Подготовка данных для графиков (СООТВЕТСТВУЕТ OCTAVE) --------------------\nexport const generateChartData = (results, options = {}) => {\n  const {\n    t,\n    tenz,\n    interf,\n    t0,\n    y0,\n    dudt_interf,\n    processedTenz,\n    t0_shifted,\n    tenz_shifted_scaled\n  } = results;\n  const step = Math.max(1, Math.floor(t.length / (options.maxPoints || 2000)));\n\n  // Ограничение точек для основных графиков\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // График 1: Исходные сигналы (как в figure 1 Octave)\n  const originalChartData = [{\n    label: \"Тензометрический сигнал\",\n    data: limitedT.map((time, idx) => ({\n      x: time,\n      y: limitedTenz[idx]\n    })),\n    borderColor: \"rgb(255,99,132)\",\n    backgroundColor: \"rgba(255,99,132,0.1)\",\n    borderWidth: 2,\n    tension: 0.1\n  }, {\n    label: \"Интерферометрический сигнал\",\n    data: limitedT.map((time, idx) => ({\n      x: time,\n      y: limitedInterf[idx]\n    })),\n    borderColor: \"rgb(54,162,235)\",\n    backgroundColor: \"rgba(54,162,235,0.1)\",\n    borderWidth: 2,\n    tension: 0.1\n  }, {\n    label: \"Нулевые пересечения\",\n    data: t0.map((time, idx) => ({\n      x: time,\n      y: y0[idx]\n    })),\n    pointStyle: \"circle\",\n    pointRadius: 4,\n    pointHoverRadius: 6,\n    borderColor: \"rgb(255,205,86)\",\n    backgroundColor: \"rgba(255,205,86,0.8)\",\n    showLine: false\n  }];\n\n  // График 2: Производная и обработанный тензосигнал (как в figure 2 Octave)\n  const processedChartData = [{\n    label: \"Производная dudt_interf\",\n    data: t0_shifted.map((time, idx) => ({\n      x: time,\n      y: dudt_interf[idx]\n    })),\n    borderColor: \"rgb(255,159,64)\",\n    backgroundColor: \"rgba(255,159,64,0.1)\",\n    borderWidth: 3,\n    pointStyle: \"circle\",\n    pointRadius: 3,\n    showLine: true\n  }, {\n    label: \"Обработанный тензосигнал\",\n    data: limitedT.map((time, idx) => ({\n      x: time + 50e-6,\n      // t+50e-6 \n      y: -tenz[idx] * 5000 + 0.38 // -tenz*5000+0.38\n    })),\n    borderColor: \"rgb(153,102,255)\",\n    backgroundColor: \"rgba(153,102,255,0.1)\",\n    borderWidth: 4,\n    tension: 0.1\n  }];\n\n  // График 3: Смещение u_interf (как в figure 3 Octave)\n  const displacementChartData = [{\n    label: \"Смещение u_interf\",\n    data: t0_shifted.map((time, idx) => ({\n      x: time,\n      y: results.u_interf[idx]\n    })),\n    borderColor: \"rgb(75,192,192)\",\n    backgroundColor: \"rgba(75,192,192,0.1)\",\n    borderWidth: 2,\n    tension: 0.1\n  }];\n  return {\n    original: originalChartData,\n    processed: processedChartData,\n    displacement: displacementChartData,\n    rawData: {\n      t: limitedT,\n      tenz: limitedTenz,\n      interf: limitedInterf,\n      t0: t0,\n      dudt_interf: dudt_interf,\n      u_interf: results.u_interf,\n      processedTenz: processedTenz\n    }\n  };\n};","map":{"version":3,"names":["processCSVData","file","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","transpose","M","map","_","i","row","multiplyMatrices","A","B","aRows","length","aCols","bCols","C","Array","from","fill","k","v","j","invertMatrix","m","n","concat","maxRow","Math","abs","diag","factor","slice","savitzkyGolay","data","windowSize","polyOrder","isArray","max","floor","out","half","sum","cnt","idx","min","p","push","pow","AT","ATA","invATA","ATAinvAT","coeffs","acc","removeBaseline","arr","N","count","avg","reduce","s","options","skipStart","skipEnd","lines","split","t","tenz","interf","dataStarted","lineCount","line","trim","startsWith","fields","timeVal","parseFloat","ch1Val","ch3Val","isNaN","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePointsMultiplePasses","u_interf","dudt_interf","calculateDerivativeFromZeroCrossings","processedTenz","processTenzSignal","t0_shifted","val","tenz_shifted_scaled","eps","y1","y2","x1","x2","t_zero","minDistance","newT0","newY0","dt_interf","du_interf","startIdx","endIdx","step","t0_out","tenz_out","sqrt","generateChartData","maxPoints","limitedT","limitedTenz","limitedInterf","originalChartData","label","time","x","y","borderColor","backgroundColor","borderWidth","tension","pointStyle","pointRadius","pointHoverRadius","showLine","processedChartData","displacementChartData","original","processed","displacement","rawData"],"sources":["C:/Users/Иван/Desktop/signal-analyzer1/src/csvProcessor.js"],"sourcesContent":["// -------------------- CSV обработка --------------------\nexport const processCSVData = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\n// -------------------- Утилиты для матриц --------------------\nconst transpose = (M) => M[0].map((_, i) => M.map(row => row[i]));\n\nconst multiplyMatrices = (A, B) => {\n  const aRows = A.length, aCols = A[0].length, bCols = B[0].length;\n  const C = Array.from({ length: aRows }, () => Array(bCols).fill(0));\n  for (let i = 0; i < aRows; i++) {\n    for (let k = 0; k < aCols; k++) {\n      const v = A[i][k];\n      for (let j = 0; j < bCols; j++) {\n        C[i][j] += v * B[k][j];\n      }\n    }\n  }\n  return C;\n};\n\nconst invertMatrix = (m) => {\n  const n = m.length;\n  const A = m.map((row, i) => row.concat(Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))));\n  for (let i = 0; i < n; i++) {\n    let maxRow = i;\n    for (let k = i + 1; k < n; k++) if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;\n    if (Math.abs(A[maxRow][i]) < 1e-15) throw new Error(\"Матрица вырождена, невозможно инвертировать\");\n    if (maxRow !== i) [A[i], A[maxRow]] = [A[maxRow], A[i]];\n    const diag = A[i][i];\n    for (let j = 0; j < 2 * n; j++) A[i][j] /= diag;\n    for (let k = 0; k < n; k++) {\n      if (k === i) continue;\n      const factor = A[k][i];\n      for (let j = 0; j < 2 * n; j++) A[k][j] -= factor * A[i][j];\n    }\n  }\n  return A.map(row => row.slice(n));\n};\n\n// -------------------- Savitzky–Golay фильтр --------------------\nconst savitzkyGolay = (data, windowSize = 31, polyOrder = 3) => {\n  if (!Array.isArray(data) || data.length === 0) return [];\n  windowSize = Math.max(3, Math.floor(windowSize));\n  if (windowSize % 2 === 0) windowSize += 1;\n  polyOrder = Math.max(1, Math.floor(polyOrder));\n  if (polyOrder >= windowSize) polyOrder = windowSize - 1;\n\n  const n = data.length;\n  if (n <= windowSize) {\n    const out = new Array(n).fill(0);\n    const half = Math.floor(windowSize / 2);\n    for (let i = 0; i < n; i++) {\n      let sum = 0, cnt = 0;\n      for (let j = i - half; j <= i + half; j++) {\n        const idx = Math.min(n - 1, Math.max(0, j));\n        sum += data[idx];\n        cnt++;\n      }\n      out[i] = sum / cnt;\n    }\n    return out;\n  }\n\n  const half = Math.floor(windowSize / 2);\n  const A = [];\n  for (let i = -half; i <= half; i++) {\n    const row = [];\n    for (let p = 0; p <= polyOrder; p++) row.push(Math.pow(i, p));\n    A.push(row);\n  }\n\n  const AT = transpose(A);\n  const ATA = multiplyMatrices(AT, A);\n  let invATA;\n  try { invATA = invertMatrix(ATA); } catch { return data.slice(); }\n  const ATAinvAT = multiplyMatrices(invATA, AT);\n  const coeffs = ATAinvAT[0];\n\n  const out = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    let acc = 0;\n    for (let j = -half; j <= half; j++) {\n      let idx = i + j; if (idx < 0) idx = 0; if (idx >= n) idx = n - 1;\n      acc += data[idx] * coeffs[j + half];\n    }\n    out[i] = acc;\n  }\n  return out;\n};\n\n// -------------------- Baseline removal --------------------\nconst removeBaseline = (arr, N = 2000) => {\n  if (!Array.isArray(arr) || arr.length === 0) return [];\n  const count = Math.min(arr.length, N);\n  const avg = arr.slice(0, count).reduce((s, v) => s + v, 0) / count;\n  return arr.map(v => v - avg);\n};\n\n// -------------------- CSV парсинг (ИСПРАВЛЕННЫЙ по логике Octave) --------------------\nconst parseCSV = (csvText, options = {}) => {\n  const skipStart = options.skipStart || 6650;\n  const skipEnd = options.skipEnd || 27000;\n\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = [];\n  const interf = [];\n\n  let dataStarted = false;\n  let lineCount = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    if (line.startsWith(\"TIME,CH1,\")) { dataStarted = true; continue; }\n    if (!dataStarted) continue;\n\n    lineCount++;\n    if (lineCount < skipStart) continue;\n    if (lineCount > skipEnd) break;\n\n    const fields = line.split(\",\");\n    if (fields.length >= 5) {\n      const timeVal = parseFloat(fields[0]);\n      const ch1Val = parseFloat(fields[1]);\n      const ch3Val = parseFloat(fields[3]);\n      if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n        t.push(timeVal);\n        tenz.push(ch1Val * 0.00132 * 1.25);\n        interf.push(ch3Val + 0.04);\n      }\n    }\n  }\n\n  // Находим нулевые пересечения как в Octave коде\n  const { t0, y0 } = findZeroCrossings(t, interf);\n  \n  // Фильтруем близкие точки (аналогично Octave циклу)\n  const { filteredT0, filteredY0 } = filterClosePointsMultiplePasses(t0, y0, 100e-9);\n\n  // Вычисляем производную по нулевым пересечениям (как в Octave)\n  const { u_interf, dudt_interf } = calculateDerivativeFromZeroCrossings(filteredT0);\n\n  // Обработанный тензосигнал (как в Octave)\n  const processedTenz = processTenzSignal(t, tenz);\n\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    processedTenz,\n    t0_shifted: filteredT0.map(val => val - 51.5e-6), // t0-51.5e-6\n    tenz_shifted_scaled: processedTenz // -tenz*5000+0.38\n  };\n};\n\n// -------------------- Нулевые пересечения (аналогично zerocrossing в Octave) --------------------\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1], y2 = interf[i], x1 = t[i - 1], x2 = t[i];\n    if (Math.abs(y1) < eps) { t0.push(x1); y0.push(0); continue; }\n    if (Math.abs(y2) < eps) { t0.push(x2); y0.push(0); continue; }\n    if (y1 * y2 < 0) {\n      const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n      t0.push(t_zero); y0.push(0);\n    }\n  }\n  return { t0, y0 };\n};\n\n// -------------------- Фильтрация близких точек (многопроходная как в Octave) --------------------\nconst filterClosePointsMultiplePasses = (t0, y0, minDistance) => {\n  if (!Array.isArray(t0) || t0.length <= 1) return { filteredT0: t0 || [], filteredY0: y0 || [] };\n  \n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n  \n  // Многопроходная фильтрация (аналогично Octave циклу while)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    \n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n    \n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n    \n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  \n  return { filteredT0, filteredY0 };\n};\n\n// -------------------- Вычисление производной по нулевым пересечениям (как в Octave) --------------------\nconst calculateDerivativeFromZeroCrossings = (t0) => {\n  const u_interf = [];\n  const dudt_interf = [];\n  const dt_interf = [];\n  const du_interf = [];\n\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n      dt_interf[i] = 0;\n      du_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      du_interf[i] = u_interf[i] - u_interf[i - 1];\n      dt_interf[i] = t0[i] - t0[i - 1];\n      dudt_interf[i] = du_interf[i] / dt_interf[i];\n    }\n  }\n\n  return { u_interf, dudt_interf, dt_interf, du_interf };\n};\n\n// -------------------- Обработка тензосигнала (как в Octave) --------------------\nconst processTenzSignal = (t, tenz) => {\n  const startIdx = 2000;\n  const endIdx = t.length - 12700;\n  const step = 10;\n  \n  const t0_out = [];\n  const tenz_out = [];\n  \n  let k = 0;\n  for (let i = startIdx; i < endIdx; i += step) {\n    t0_out[k] = t[i] - t[startIdx];\n    // -(-tenz(i,1)*5000+0.47)*sqrt(71e9*2770)\n    tenz_out[k] = -(-tenz[i] * 5000 + 0.47) * Math.sqrt(71e9 * 2770);\n    k++;\n  }\n  \n  return tenz_out;\n};\n\n// -------------------- Подготовка данных для графиков (СООТВЕТСТВУЕТ OCTAVE) --------------------\nexport const generateChartData = (results, options = {}) => {\n  const { \n    t, \n    tenz, \n    interf, \n    t0, \n    y0, \n    dudt_interf, \n    processedTenz,\n    t0_shifted,\n    tenz_shifted_scaled\n  } = results;\n\n  const step = Math.max(1, Math.floor(t.length / (options.maxPoints || 2000)));\n\n  // Ограничение точек для основных графиков\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // График 1: Исходные сигналы (как в figure 1 Octave)\n  const originalChartData = [\n    { \n      label: \"Тензометрический сигнал\", \n      data: limitedT.map((time, idx) => ({ x: time, y: limitedTenz[idx] })), \n      borderColor: \"rgb(255,99,132)\", \n      backgroundColor: \"rgba(255,99,132,0.1)\", \n      borderWidth: 2, \n      tension: 0.1 \n    },\n    { \n      label: \"Интерферометрический сигнал\", \n      data: limitedT.map((time, idx) => ({ x: time, y: limitedInterf[idx] })), \n      borderColor: \"rgb(54,162,235)\", \n      backgroundColor: \"rgba(54,162,235,0.1)\", \n      borderWidth: 2, \n      tension: 0.1 \n    },\n    { \n      label: \"Нулевые пересечения\", \n      data: t0.map((time, idx) => ({ x: time, y: y0[idx] })), \n      pointStyle: \"circle\",\n      pointRadius: 4,\n      pointHoverRadius: 6,\n      borderColor: \"rgb(255,205,86)\",\n      backgroundColor: \"rgba(255,205,86,0.8)\",\n      showLine: false\n    }\n  ];\n\n  // График 2: Производная и обработанный тензосигнал (как в figure 2 Octave)\n  const processedChartData = [\n    { \n      label: \"Производная dudt_interf\", \n      data: t0_shifted.map((time, idx) => ({ x: time, y: dudt_interf[idx] })), \n      borderColor: \"rgb(255,159,64)\", \n      backgroundColor: \"rgba(255,159,64,0.1)\", \n      borderWidth: 3, \n      pointStyle: \"circle\",\n      pointRadius: 3,\n      showLine: true\n    },\n    { \n      label: \"Обработанный тензосигнал\", \n      data: limitedT.map((time, idx) => ({ \n        x: time + 50e-6, // t+50e-6 \n        y: -tenz[idx] * 5000 + 0.38 // -tenz*5000+0.38\n      })), \n      borderColor: \"rgb(153,102,255)\", \n      backgroundColor: \"rgba(153,102,255,0.1)\", \n      borderWidth: 4, \n      tension: 0.1 \n    }\n  ];\n\n  // График 3: Смещение u_interf (как в figure 3 Octave)\n  const displacementChartData = [\n    { \n      label: \"Смещение u_interf\", \n      data: t0_shifted.map((time, idx) => ({ x: time, y: results.u_interf[idx] })), \n      borderColor: \"rgb(75,192,192)\", \n      backgroundColor: \"rgba(75,192,192,0.1)\", \n      borderWidth: 2, \n      tension: 0.1 \n    }\n  ];\n\n  return {\n    original: originalChartData,\n    processed: processedChartData,\n    displacement: displacementChartData,\n    rawData: {\n      t: limitedT,\n      tenz: limitedTenz,\n      interf: limitedInterf,\n      t0: t0,\n      dudt_interf: dudt_interf,\n      u_interf: results.u_interf,\n      processedTenz: processedTenz\n    }\n  };\n};"],"mappings":"AAAA;AACA,OAAO,MAAMA,cAAc,GAAIC,IAAI,IAAK;EACtC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAE/BD,MAAM,CAACE,MAAM,GAAIC,CAAC,IAAK;MACrB,IAAI;QACF,MAAMC,OAAO,GAAGD,CAAC,CAACE,MAAM,CAACC,MAAM;QAC/B,MAAMC,OAAO,GAAGC,QAAQ,CAACJ,OAAO,CAAC;QACjCN,OAAO,CAACS,OAAO,CAAC;MAClB,CAAC,CAAC,OAAOE,KAAK,EAAE;QACdV,MAAM,CAACU,KAAK,CAAC;MACf;IACF,CAAC;IAEDT,MAAM,CAACU,OAAO,GAAG,MAAMX,MAAM,CAAC,IAAIY,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC/DX,MAAM,CAACY,UAAU,CAAChB,IAAI,CAAC;EACzB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,MAAMiB,SAAS,GAAIC,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKH,CAAC,CAACC,GAAG,CAACG,GAAG,IAAIA,GAAG,CAACD,CAAC,CAAC,CAAC,CAAC;AAEjE,MAAME,gBAAgB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACjC,MAAMC,KAAK,GAAGF,CAAC,CAACG,MAAM;IAAEC,KAAK,GAAGJ,CAAC,CAAC,CAAC,CAAC,CAACG,MAAM;IAAEE,KAAK,GAAGJ,CAAC,CAAC,CAAC,CAAC,CAACE,MAAM;EAChE,MAAMG,CAAC,GAAGC,KAAK,CAACC,IAAI,CAAC;IAAEL,MAAM,EAAED;EAAM,CAAC,EAAE,MAAMK,KAAK,CAACF,KAAK,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC;EACnE,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,KAAK,EAAEL,CAAC,EAAE,EAAE;IAC9B,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,KAAK,EAAEM,CAAC,EAAE,EAAE;MAC9B,MAAMC,CAAC,GAAGX,CAAC,CAACH,CAAC,CAAC,CAACa,CAAC,CAAC;MACjB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,EAAEO,CAAC,EAAE,EAAE;QAC9BN,CAAC,CAACT,CAAC,CAAC,CAACe,CAAC,CAAC,IAAID,CAAC,GAAGV,CAAC,CAACS,CAAC,CAAC,CAACE,CAAC,CAAC;MACxB;IACF;EACF;EACA,OAAON,CAAC;AACV,CAAC;AAED,MAAMO,YAAY,GAAIC,CAAC,IAAK;EAC1B,MAAMC,CAAC,GAAGD,CAAC,CAACX,MAAM;EAClB,MAAMH,CAAC,GAAGc,CAAC,CAACnB,GAAG,CAAC,CAACG,GAAG,EAAED,CAAC,KAAKC,GAAG,CAACkB,MAAM,CAACT,KAAK,CAACC,IAAI,CAAC;IAAEL,MAAM,EAAEY;EAAE,CAAC,EAAE,CAACnB,CAAC,EAAEgB,CAAC,KAAMf,CAAC,KAAKe,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC,CAAC,CAAC;EAC/F,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;IAC1B,IAAIoB,MAAM,GAAGpB,CAAC;IACd,KAAK,IAAIa,CAAC,GAAGb,CAAC,GAAG,CAAC,EAAEa,CAAC,GAAGK,CAAC,EAAEL,CAAC,EAAE,EAAE,IAAIQ,IAAI,CAACC,GAAG,CAACnB,CAAC,CAACU,CAAC,CAAC,CAACb,CAAC,CAAC,CAAC,GAAGqB,IAAI,CAACC,GAAG,CAACnB,CAAC,CAACiB,MAAM,CAAC,CAACpB,CAAC,CAAC,CAAC,EAAEoB,MAAM,GAAGP,CAAC;IAC1F,IAAIQ,IAAI,CAACC,GAAG,CAACnB,CAAC,CAACiB,MAAM,CAAC,CAACpB,CAAC,CAAC,CAAC,GAAG,KAAK,EAAE,MAAM,IAAIN,KAAK,CAAC,6CAA6C,CAAC;IAClG,IAAI0B,MAAM,KAAKpB,CAAC,EAAE,CAACG,CAAC,CAACH,CAAC,CAAC,EAAEG,CAAC,CAACiB,MAAM,CAAC,CAAC,GAAG,CAACjB,CAAC,CAACiB,MAAM,CAAC,EAAEjB,CAAC,CAACH,CAAC,CAAC,CAAC;IACvD,MAAMuB,IAAI,GAAGpB,CAAC,CAACH,CAAC,CAAC,CAACA,CAAC,CAAC;IACpB,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,GAAGG,CAAC,EAAEH,CAAC,EAAE,EAAEZ,CAAC,CAACH,CAAC,CAAC,CAACe,CAAC,CAAC,IAAIQ,IAAI;IAC/C,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,CAAC,EAAEL,CAAC,EAAE,EAAE;MAC1B,IAAIA,CAAC,KAAKb,CAAC,EAAE;MACb,MAAMwB,MAAM,GAAGrB,CAAC,CAACU,CAAC,CAAC,CAACb,CAAC,CAAC;MACtB,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,GAAGG,CAAC,EAAEH,CAAC,EAAE,EAAEZ,CAAC,CAACU,CAAC,CAAC,CAACE,CAAC,CAAC,IAAIS,MAAM,GAAGrB,CAAC,CAACH,CAAC,CAAC,CAACe,CAAC,CAAC;IAC7D;EACF;EACA,OAAOZ,CAAC,CAACL,GAAG,CAACG,GAAG,IAAIA,GAAG,CAACwB,KAAK,CAACP,CAAC,CAAC,CAAC;AACnC,CAAC;;AAED;AACA,MAAMQ,aAAa,GAAGA,CAACC,IAAI,EAAEC,UAAU,GAAG,EAAE,EAAEC,SAAS,GAAG,CAAC,KAAK;EAC9D,IAAI,CAACnB,KAAK,CAACoB,OAAO,CAACH,IAAI,CAAC,IAAIA,IAAI,CAACrB,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EACxDsB,UAAU,GAAGP,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEV,IAAI,CAACW,KAAK,CAACJ,UAAU,CAAC,CAAC;EAChD,IAAIA,UAAU,GAAG,CAAC,KAAK,CAAC,EAAEA,UAAU,IAAI,CAAC;EACzCC,SAAS,GAAGR,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEV,IAAI,CAACW,KAAK,CAACH,SAAS,CAAC,CAAC;EAC9C,IAAIA,SAAS,IAAID,UAAU,EAAEC,SAAS,GAAGD,UAAU,GAAG,CAAC;EAEvD,MAAMV,CAAC,GAAGS,IAAI,CAACrB,MAAM;EACrB,IAAIY,CAAC,IAAIU,UAAU,EAAE;IACnB,MAAMK,GAAG,GAAG,IAAIvB,KAAK,CAACQ,CAAC,CAAC,CAACN,IAAI,CAAC,CAAC,CAAC;IAChC,MAAMsB,IAAI,GAAGb,IAAI,CAACW,KAAK,CAACJ,UAAU,GAAG,CAAC,CAAC;IACvC,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;MAC1B,IAAImC,GAAG,GAAG,CAAC;QAAEC,GAAG,GAAG,CAAC;MACpB,KAAK,IAAIrB,CAAC,GAAGf,CAAC,GAAGkC,IAAI,EAAEnB,CAAC,IAAIf,CAAC,GAAGkC,IAAI,EAAEnB,CAAC,EAAE,EAAE;QACzC,MAAMsB,GAAG,GAAGhB,IAAI,CAACiB,GAAG,CAACpB,CAAC,GAAG,CAAC,EAAEG,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEhB,CAAC,CAAC,CAAC;QAC3CoB,GAAG,IAAIR,IAAI,CAACU,GAAG,CAAC;QAChBD,GAAG,EAAE;MACP;MACAH,GAAG,CAACjC,CAAC,CAAC,GAAGmC,GAAG,GAAGC,GAAG;IACpB;IACA,OAAOH,GAAG;EACZ;EAEA,MAAMC,IAAI,GAAGb,IAAI,CAACW,KAAK,CAACJ,UAAU,GAAG,CAAC,CAAC;EACvC,MAAMzB,CAAC,GAAG,EAAE;EACZ,KAAK,IAAIH,CAAC,GAAG,CAACkC,IAAI,EAAElC,CAAC,IAAIkC,IAAI,EAAElC,CAAC,EAAE,EAAE;IAClC,MAAMC,GAAG,GAAG,EAAE;IACd,KAAK,IAAIsC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIV,SAAS,EAAEU,CAAC,EAAE,EAAEtC,GAAG,CAACuC,IAAI,CAACnB,IAAI,CAACoB,GAAG,CAACzC,CAAC,EAAEuC,CAAC,CAAC,CAAC;IAC7DpC,CAAC,CAACqC,IAAI,CAACvC,GAAG,CAAC;EACb;EAEA,MAAMyC,EAAE,GAAG9C,SAAS,CAACO,CAAC,CAAC;EACvB,MAAMwC,GAAG,GAAGzC,gBAAgB,CAACwC,EAAE,EAAEvC,CAAC,CAAC;EACnC,IAAIyC,MAAM;EACV,IAAI;IAAEA,MAAM,GAAG5B,YAAY,CAAC2B,GAAG,CAAC;EAAE,CAAC,CAAC,MAAM;IAAE,OAAOhB,IAAI,CAACF,KAAK,CAAC,CAAC;EAAE;EACjE,MAAMoB,QAAQ,GAAG3C,gBAAgB,CAAC0C,MAAM,EAAEF,EAAE,CAAC;EAC7C,MAAMI,MAAM,GAAGD,QAAQ,CAAC,CAAC,CAAC;EAE1B,MAAMZ,GAAG,GAAG,IAAIvB,KAAK,CAACQ,CAAC,CAAC,CAACN,IAAI,CAAC,CAAC,CAAC;EAChC,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;IAC1B,IAAI+C,GAAG,GAAG,CAAC;IACX,KAAK,IAAIhC,CAAC,GAAG,CAACmB,IAAI,EAAEnB,CAAC,IAAImB,IAAI,EAAEnB,CAAC,EAAE,EAAE;MAClC,IAAIsB,GAAG,GAAGrC,CAAC,GAAGe,CAAC;MAAE,IAAIsB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC;MAAE,IAAIA,GAAG,IAAInB,CAAC,EAAEmB,GAAG,GAAGnB,CAAC,GAAG,CAAC;MAChE6B,GAAG,IAAIpB,IAAI,CAACU,GAAG,CAAC,GAAGS,MAAM,CAAC/B,CAAC,GAAGmB,IAAI,CAAC;IACrC;IACAD,GAAG,CAACjC,CAAC,CAAC,GAAG+C,GAAG;EACd;EACA,OAAOd,GAAG;AACZ,CAAC;;AAED;AACA,MAAMe,cAAc,GAAGA,CAACC,GAAG,EAAEC,CAAC,GAAG,IAAI,KAAK;EACxC,IAAI,CAACxC,KAAK,CAACoB,OAAO,CAACmB,GAAG,CAAC,IAAIA,GAAG,CAAC3C,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;EACtD,MAAM6C,KAAK,GAAG9B,IAAI,CAACiB,GAAG,CAACW,GAAG,CAAC3C,MAAM,EAAE4C,CAAC,CAAC;EACrC,MAAME,GAAG,GAAGH,GAAG,CAACxB,KAAK,CAAC,CAAC,EAAE0B,KAAK,CAAC,CAACE,MAAM,CAAC,CAACC,CAAC,EAAExC,CAAC,KAAKwC,CAAC,GAAGxC,CAAC,EAAE,CAAC,CAAC,GAAGqC,KAAK;EAClE,OAAOF,GAAG,CAACnD,GAAG,CAACgB,CAAC,IAAIA,CAAC,GAAGsC,GAAG,CAAC;AAC9B,CAAC;;AAED;AACA,MAAM7D,QAAQ,GAAGA,CAACJ,OAAO,EAAEoE,OAAO,GAAG,CAAC,CAAC,KAAK;EAC1C,MAAMC,SAAS,GAAGD,OAAO,CAACC,SAAS,IAAI,IAAI;EAC3C,MAAMC,OAAO,GAAGF,OAAO,CAACE,OAAO,IAAI,KAAK;EAExC,MAAMC,KAAK,GAAGvE,OAAO,CAACwE,KAAK,CAAC,IAAI,CAAC;EACjC,MAAMC,CAAC,GAAG,EAAE;EACZ,MAAMC,IAAI,GAAG,EAAE;EACf,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAIC,WAAW,GAAG,KAAK;EACvB,IAAIC,SAAS,GAAG,CAAC;EAEjB,KAAK,IAAIhE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0D,KAAK,CAACpD,MAAM,EAAEN,CAAC,EAAE,EAAE;IACrC,MAAMiE,IAAI,GAAGP,KAAK,CAAC1D,CAAC,CAAC,CAACkE,IAAI,CAAC,CAAC;IAC5B,IAAI,CAACD,IAAI,EAAE;IACX,IAAIA,IAAI,CAACE,UAAU,CAAC,WAAW,CAAC,EAAE;MAAEJ,WAAW,GAAG,IAAI;MAAE;IAAU;IAClE,IAAI,CAACA,WAAW,EAAE;IAElBC,SAAS,EAAE;IACX,IAAIA,SAAS,GAAGR,SAAS,EAAE;IAC3B,IAAIQ,SAAS,GAAGP,OAAO,EAAE;IAEzB,MAAMW,MAAM,GAAGH,IAAI,CAACN,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAIS,MAAM,CAAC9D,MAAM,IAAI,CAAC,EAAE;MACtB,MAAM+D,OAAO,GAAGC,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;MACrC,MAAMG,MAAM,GAAGD,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;MACpC,MAAMI,MAAM,GAAGF,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;MACpC,IAAI,CAACK,KAAK,CAACJ,OAAO,CAAC,IAAI,CAACI,KAAK,CAACF,MAAM,CAAC,IAAI,CAACE,KAAK,CAACD,MAAM,CAAC,EAAE;QACvDZ,CAAC,CAACpB,IAAI,CAAC6B,OAAO,CAAC;QACfR,IAAI,CAACrB,IAAI,CAAC+B,MAAM,GAAG,OAAO,GAAG,IAAI,CAAC;QAClCT,MAAM,CAACtB,IAAI,CAACgC,MAAM,GAAG,IAAI,CAAC;MAC5B;IACF;EACF;;EAEA;EACA,MAAM;IAAEE,EAAE;IAAEC;EAAG,CAAC,GAAGC,iBAAiB,CAAChB,CAAC,EAAEE,MAAM,CAAC;;EAE/C;EACA,MAAM;IAAEe,UAAU;IAAEC;EAAW,CAAC,GAAGC,+BAA+B,CAACL,EAAE,EAAEC,EAAE,EAAE,MAAM,CAAC;;EAElF;EACA,MAAM;IAAEK,QAAQ;IAAEC;EAAY,CAAC,GAAGC,oCAAoC,CAACL,UAAU,CAAC;;EAElF;EACA,MAAMM,aAAa,GAAGC,iBAAiB,CAACxB,CAAC,EAAEC,IAAI,CAAC;EAEhD,OAAO;IACLD,CAAC;IACDC,IAAI;IACJC,MAAM;IACNY,EAAE,EAAEG,UAAU;IACdF,EAAE,EAAEG,UAAU;IACdE,QAAQ;IACRC,WAAW;IACXE,aAAa;IACbE,UAAU,EAAER,UAAU,CAAC/E,GAAG,CAACwF,GAAG,IAAIA,GAAG,GAAG,OAAO,CAAC;IAAE;IAClDC,mBAAmB,EAAEJ,aAAa,CAAC;EACrC,CAAC;AACH,CAAC;;AAED;AACA,MAAMP,iBAAiB,GAAGA,CAAChB,CAAC,EAAEE,MAAM,EAAE0B,GAAG,GAAG,IAAI,KAAK;EACnD,MAAMd,EAAE,GAAG,EAAE;EACb,MAAMC,EAAE,GAAG,EAAE;EACb,KAAK,IAAI3E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,MAAM,CAACxD,MAAM,EAAEN,CAAC,EAAE,EAAE;IACtC,MAAMyF,EAAE,GAAG3B,MAAM,CAAC9D,CAAC,GAAG,CAAC,CAAC;MAAE0F,EAAE,GAAG5B,MAAM,CAAC9D,CAAC,CAAC;MAAE2F,EAAE,GAAG/B,CAAC,CAAC5D,CAAC,GAAG,CAAC,CAAC;MAAE4F,EAAE,GAAGhC,CAAC,CAAC5D,CAAC,CAAC;IAClE,IAAIqB,IAAI,CAACC,GAAG,CAACmE,EAAE,CAAC,GAAGD,GAAG,EAAE;MAAEd,EAAE,CAAClC,IAAI,CAACmD,EAAE,CAAC;MAAEhB,EAAE,CAACnC,IAAI,CAAC,CAAC,CAAC;MAAE;IAAU;IAC7D,IAAInB,IAAI,CAACC,GAAG,CAACoE,EAAE,CAAC,GAAGF,GAAG,EAAE;MAAEd,EAAE,CAAClC,IAAI,CAACoD,EAAE,CAAC;MAAEjB,EAAE,CAACnC,IAAI,CAAC,CAAC,CAAC;MAAE;IAAU;IAC7D,IAAIiD,EAAE,GAAGC,EAAE,GAAG,CAAC,EAAE;MACf,MAAMG,MAAM,GAAGF,EAAE,GAAGF,EAAE,IAAIG,EAAE,GAAGD,EAAE,CAAC,IAAID,EAAE,GAAGD,EAAE,CAAC;MAC9Cf,EAAE,CAAClC,IAAI,CAACqD,MAAM,CAAC;MAAElB,EAAE,CAACnC,IAAI,CAAC,CAAC,CAAC;IAC7B;EACF;EACA,OAAO;IAAEkC,EAAE;IAAEC;EAAG,CAAC;AACnB,CAAC;;AAED;AACA,MAAMI,+BAA+B,GAAGA,CAACL,EAAE,EAAEC,EAAE,EAAEmB,WAAW,KAAK;EAC/D,IAAI,CAACpF,KAAK,CAACoB,OAAO,CAAC4C,EAAE,CAAC,IAAIA,EAAE,CAACpE,MAAM,IAAI,CAAC,EAAE,OAAO;IAAEuE,UAAU,EAAEH,EAAE,IAAI,EAAE;IAAEI,UAAU,EAAEH,EAAE,IAAI;EAAG,CAAC;EAE/F,IAAIE,UAAU,GAAG,CAAC,GAAGH,EAAE,CAAC;EACxB,IAAII,UAAU,GAAG,CAAC,GAAGH,EAAE,CAAC;;EAExB;EACA,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3B,MAAMkF,KAAK,GAAG,CAAClB,UAAU,CAAC,CAAC,CAAC,CAAC;IAC7B,MAAMmB,KAAK,GAAG,CAAClB,UAAU,CAAC,CAAC,CAAC,CAAC;IAE7B,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6E,UAAU,CAACvE,MAAM,EAAEN,CAAC,EAAE,EAAE;MAC1C,IAAI6E,UAAU,CAAC7E,CAAC,CAAC,GAAG+F,KAAK,CAACA,KAAK,CAACzF,MAAM,GAAG,CAAC,CAAC,IAAIwF,WAAW,EAAE;QAC1DC,KAAK,CAACvD,IAAI,CAACqC,UAAU,CAAC7E,CAAC,CAAC,CAAC;QACzBgG,KAAK,CAACxD,IAAI,CAACsC,UAAU,CAAC9E,CAAC,CAAC,CAAC;MAC3B;IACF;;IAEA;IACA,IAAI+F,KAAK,CAACzF,MAAM,KAAKuE,UAAU,CAACvE,MAAM,EAAE;IAExCuE,UAAU,GAAGkB,KAAK;IAClBjB,UAAU,GAAGkB,KAAK;EACpB;EAEA,OAAO;IAAEnB,UAAU;IAAEC;EAAW,CAAC;AACnC,CAAC;;AAED;AACA,MAAMI,oCAAoC,GAAIR,EAAE,IAAK;EACnD,MAAMM,QAAQ,GAAG,EAAE;EACnB,MAAMC,WAAW,GAAG,EAAE;EACtB,MAAMgB,SAAS,GAAG,EAAE;EACpB,MAAMC,SAAS,GAAG,EAAE;EAEpB,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0E,EAAE,CAACpE,MAAM,EAAEN,CAAC,EAAE,EAAE;IAClC,IAAIA,CAAC,KAAK,CAAC,EAAE;MACXgF,QAAQ,CAAChF,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,IAAI;MAC7BiF,WAAW,CAACjF,CAAC,CAAC,GAAG,CAAC;MAClBiG,SAAS,CAACjG,CAAC,CAAC,GAAG,CAAC;MAChBkG,SAAS,CAAClG,CAAC,CAAC,GAAG,CAAC;IAClB,CAAC,MAAM;MACLgF,QAAQ,CAAChF,CAAC,CAAC,GAAGgF,QAAQ,CAAChF,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,IAAI;MAC/CkG,SAAS,CAAClG,CAAC,CAAC,GAAGgF,QAAQ,CAAChF,CAAC,CAAC,GAAGgF,QAAQ,CAAChF,CAAC,GAAG,CAAC,CAAC;MAC5CiG,SAAS,CAACjG,CAAC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC,CAAC,GAAG0E,EAAE,CAAC1E,CAAC,GAAG,CAAC,CAAC;MAChCiF,WAAW,CAACjF,CAAC,CAAC,GAAGkG,SAAS,CAAClG,CAAC,CAAC,GAAGiG,SAAS,CAACjG,CAAC,CAAC;IAC9C;EACF;EAEA,OAAO;IAAEgF,QAAQ;IAAEC,WAAW;IAAEgB,SAAS;IAAEC;EAAU,CAAC;AACxD,CAAC;;AAED;AACA,MAAMd,iBAAiB,GAAGA,CAACxB,CAAC,EAAEC,IAAI,KAAK;EACrC,MAAMsC,QAAQ,GAAG,IAAI;EACrB,MAAMC,MAAM,GAAGxC,CAAC,CAACtD,MAAM,GAAG,KAAK;EAC/B,MAAM+F,IAAI,GAAG,EAAE;EAEf,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,QAAQ,GAAG,EAAE;EAEnB,IAAI1F,CAAC,GAAG,CAAC;EACT,KAAK,IAAIb,CAAC,GAAGmG,QAAQ,EAAEnG,CAAC,GAAGoG,MAAM,EAAEpG,CAAC,IAAIqG,IAAI,EAAE;IAC5CC,MAAM,CAACzF,CAAC,CAAC,GAAG+C,CAAC,CAAC5D,CAAC,CAAC,GAAG4D,CAAC,CAACuC,QAAQ,CAAC;IAC9B;IACAI,QAAQ,CAAC1F,CAAC,CAAC,GAAG,EAAE,CAACgD,IAAI,CAAC7D,CAAC,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,GAAGqB,IAAI,CAACmF,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IAChE3F,CAAC,EAAE;EACL;EAEA,OAAO0F,QAAQ;AACjB,CAAC;;AAED;AACA,OAAO,MAAME,iBAAiB,GAAGA,CAACnH,OAAO,EAAEiE,OAAO,GAAG,CAAC,CAAC,KAAK;EAC1D,MAAM;IACJK,CAAC;IACDC,IAAI;IACJC,MAAM;IACNY,EAAE;IACFC,EAAE;IACFM,WAAW;IACXE,aAAa;IACbE,UAAU;IACVE;EACF,CAAC,GAAGjG,OAAO;EAEX,MAAM+G,IAAI,GAAGhF,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEV,IAAI,CAACW,KAAK,CAAC4B,CAAC,CAACtD,MAAM,IAAIiD,OAAO,CAACmD,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC;;EAE5E;EACA,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAMC,WAAW,GAAG,EAAE;EACtB,MAAMC,aAAa,GAAG,EAAE;EACxB,KAAK,IAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4D,CAAC,CAACtD,MAAM,EAAEN,CAAC,IAAIqG,IAAI,EAAE;IACvCM,QAAQ,CAACnE,IAAI,CAACoB,CAAC,CAAC5D,CAAC,CAAC,CAAC;IACnB4G,WAAW,CAACpE,IAAI,CAACqB,IAAI,CAAC7D,CAAC,CAAC,CAAC;IACzB6G,aAAa,CAACrE,IAAI,CAACsB,MAAM,CAAC9D,CAAC,CAAC,CAAC;EAC/B;;EAEA;EACA,MAAM8G,iBAAiB,GAAG,CACxB;IACEC,KAAK,EAAE,yBAAyB;IAChCpF,IAAI,EAAEgF,QAAQ,CAAC7G,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MAAE4E,CAAC,EAAED,IAAI;MAAEE,CAAC,EAAEN,WAAW,CAACvE,GAAG;IAAE,CAAC,CAAC,CAAC;IACrE8E,WAAW,EAAE,iBAAiB;IAC9BC,eAAe,EAAE,sBAAsB;IACvCC,WAAW,EAAE,CAAC;IACdC,OAAO,EAAE;EACX,CAAC,EACD;IACEP,KAAK,EAAE,6BAA6B;IACpCpF,IAAI,EAAEgF,QAAQ,CAAC7G,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MAAE4E,CAAC,EAAED,IAAI;MAAEE,CAAC,EAAEL,aAAa,CAACxE,GAAG;IAAE,CAAC,CAAC,CAAC;IACvE8E,WAAW,EAAE,iBAAiB;IAC9BC,eAAe,EAAE,sBAAsB;IACvCC,WAAW,EAAE,CAAC;IACdC,OAAO,EAAE;EACX,CAAC,EACD;IACEP,KAAK,EAAE,qBAAqB;IAC5BpF,IAAI,EAAE+C,EAAE,CAAC5E,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MAAE4E,CAAC,EAAED,IAAI;MAAEE,CAAC,EAAEvC,EAAE,CAACtC,GAAG;IAAE,CAAC,CAAC,CAAC;IACtDkF,UAAU,EAAE,QAAQ;IACpBC,WAAW,EAAE,CAAC;IACdC,gBAAgB,EAAE,CAAC;IACnBN,WAAW,EAAE,iBAAiB;IAC9BC,eAAe,EAAE,sBAAsB;IACvCM,QAAQ,EAAE;EACZ,CAAC,CACF;;EAED;EACA,MAAMC,kBAAkB,GAAG,CACzB;IACEZ,KAAK,EAAE,yBAAyB;IAChCpF,IAAI,EAAE0D,UAAU,CAACvF,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MAAE4E,CAAC,EAAED,IAAI;MAAEE,CAAC,EAAEjC,WAAW,CAAC5C,GAAG;IAAE,CAAC,CAAC,CAAC;IACvE8E,WAAW,EAAE,iBAAiB;IAC9BC,eAAe,EAAE,sBAAsB;IACvCC,WAAW,EAAE,CAAC;IACdE,UAAU,EAAE,QAAQ;IACpBC,WAAW,EAAE,CAAC;IACdE,QAAQ,EAAE;EACZ,CAAC,EACD;IACEX,KAAK,EAAE,0BAA0B;IACjCpF,IAAI,EAAEgF,QAAQ,CAAC7G,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MACjC4E,CAAC,EAAED,IAAI,GAAG,KAAK;MAAE;MACjBE,CAAC,EAAE,CAACrD,IAAI,CAACxB,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;IAC9B,CAAC,CAAC,CAAC;IACH8E,WAAW,EAAE,kBAAkB;IAC/BC,eAAe,EAAE,uBAAuB;IACxCC,WAAW,EAAE,CAAC;IACdC,OAAO,EAAE;EACX,CAAC,CACF;;EAED;EACA,MAAMM,qBAAqB,GAAG,CAC5B;IACEb,KAAK,EAAE,mBAAmB;IAC1BpF,IAAI,EAAE0D,UAAU,CAACvF,GAAG,CAAC,CAACkH,IAAI,EAAE3E,GAAG,MAAM;MAAE4E,CAAC,EAAED,IAAI;MAAEE,CAAC,EAAE5H,OAAO,CAAC0F,QAAQ,CAAC3C,GAAG;IAAE,CAAC,CAAC,CAAC;IAC5E8E,WAAW,EAAE,iBAAiB;IAC9BC,eAAe,EAAE,sBAAsB;IACvCC,WAAW,EAAE,CAAC;IACdC,OAAO,EAAE;EACX,CAAC,CACF;EAED,OAAO;IACLO,QAAQ,EAAEf,iBAAiB;IAC3BgB,SAAS,EAAEH,kBAAkB;IAC7BI,YAAY,EAAEH,qBAAqB;IACnCI,OAAO,EAAE;MACPpE,CAAC,EAAE+C,QAAQ;MACX9C,IAAI,EAAE+C,WAAW;MACjB9C,MAAM,EAAE+C,aAAa;MACrBnC,EAAE,EAAEA,EAAE;MACNO,WAAW,EAAEA,WAAW;MACxBD,QAAQ,EAAE1F,OAAO,CAAC0F,QAAQ;MAC1BG,aAAa,EAAEA;IACjB;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}