{"ast":null,"code":"// Полный обновлённый файл — Savitzky-Golay (без внешних библиотек), baseline removal,\n// сглаживание, поиск нулевых пересечений, фильтрация близких точек и подготовка данных для графиков.\n\nexport const processCSVData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\n// -------------------- Утилиты для матриц (используются для SG) --------------------\nconst transpose = M => M[0].map((_, i) => M.map(row => row[i]));\nconst multiplyMatrices = (A, B) => {\n  const aRows = A.length,\n    aCols = A[0].length,\n    bCols = B[0].length;\n  const C = Array.from({\n    length: aRows\n  }, () => Array(bCols).fill(0));\n  for (let i = 0; i < aRows; i++) {\n    for (let k = 0; k < aCols; k++) {\n      const v = A[i][k];\n      for (let j = 0; j < bCols; j++) {\n        C[i][j] += v * B[k][j];\n      }\n    }\n  }\n  return C;\n};\nconst invertMatrix = m => {\n  const n = m.length;\n  // Создаём расширенную матрицу [m | I]\n  const A = m.map((row, i) => row.concat(Array.from({\n    length: n\n  }, (_, j) => i === j ? 1 : 0)));\n  // Прямой ход\n  for (let i = 0; i < n; i++) {\n    // Находим максимальный по модулю элемент в столбце (для устойчивости)\n    let maxRow = i;\n    for (let k = i + 1; k < n; k++) {\n      if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;\n    }\n    if (Math.abs(A[maxRow][i]) < 1e-15) {\n      throw new Error(\"Матрица вырождена, невозможно инвертировать\");\n    }\n    // Меняем строки\n    if (maxRow !== i) {\n      const tmp = A[i];\n      A[i] = A[maxRow];\n      A[maxRow] = tmp;\n    }\n    // Нормируем строку\n    const diag = A[i][i];\n    for (let j = 0; j < 2 * n; j++) A[i][j] /= diag;\n    // Исключаем ниже\n    for (let k = 0; k < n; k++) {\n      if (k === i) continue;\n      const factor = A[k][i];\n      if (factor === 0) continue;\n      for (let j = 0; j < 2 * n; j++) {\n        A[k][j] -= factor * A[i][j];\n      }\n    }\n  }\n  // Извлекаем правую половину — обратную матрицу\n  return A.map(row => row.slice(n));\n};\n\n// -------------------- Savitzky–Golay фильтр (реализация без зависимостей) --------------------\nconst savitzkyGolay = (data, windowSize = 31, polyOrder = 3) => {\n  // Параметры sanity\n  if (!Array.isArray(data) || data.length === 0) return [];\n  windowSize = Math.max(3, Math.floor(windowSize));\n  if (windowSize % 2 === 0) windowSize += 1;\n  polyOrder = Math.max(1, Math.floor(polyOrder));\n  if (polyOrder >= windowSize) polyOrder = windowSize - 1;\n  const n = data.length;\n  if (n <= windowSize) {\n    // Если данных меньше окна — возвращаем простое сглаживание (скользящее среднее)\n    const out = new Array(n).fill(0);\n    const half = Math.floor(windowSize / 2);\n    for (let i = 0; i < n; i++) {\n      let sum = 0,\n        cnt = 0;\n      for (let j = i - half; j <= i + half; j++) {\n        const idx = Math.min(n - 1, Math.max(0, j));\n        sum += data[idx];\n        cnt++;\n      }\n      out[i] = sum / cnt;\n    }\n    return out;\n  }\n  const half = Math.floor(windowSize / 2);\n\n  // Строим матрицу A размера windowSize x (polyOrder+1)\n  const A = [];\n  for (let i = -half; i <= half; i++) {\n    const row = [];\n    for (let p = 0; p <= polyOrder; p++) row.push(Math.pow(i, p));\n    A.push(row);\n  }\n  const AT = transpose(A);\n  const ATA = multiplyMatrices(AT, A);\n\n  // Инвертируем ATA\n  let invATA;\n  try {\n    invATA = invertMatrix(ATA);\n  } catch (err) {\n    // В случае проблем с инверсией возвращаем 원본\n    return data.slice();\n  }\n\n  // ATA^{-1} * AT  -> матрица (polyOrder+1) x windowSize\n  const ATAinvAT = multiplyMatrices(invATA, AT);\n\n  // Коэффициенты для сглаживания центральной точки — это row 0 (нольй порядок)\n  // Фактически нам нужны веса w_j так, что smoothed[i] = sum_j w_j * data[i+j-half]\n  const coeffs = ATAinvAT[0]; // длина = windowSize\n\n  // Применяем свёртку с коэффициентами, на границах репликация краевых значений\n  const out = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    let acc = 0;\n    for (let j = -half; j <= half; j++) {\n      let idx = i + j;\n      if (idx < 0) idx = 0;\n      if (idx >= n) idx = n - 1;\n      acc += data[idx] * coeffs[j + half];\n    }\n    out[i] = acc;\n  }\n  return out;\n};\n\n// -------------------- Baseline removal --------------------\nconst removeBaseline = (arr, N = 2000) => {\n  if (!Array.isArray(arr) || arr.length === 0) return [];\n  const count = Math.min(arr.length, N);\n  const avg = arr.slice(0, count).reduce((s, v) => s + v, 0) / count;\n  return arr.map(v => v - avg);\n};\n\n// -------------------- Парсинг CSV и основной поток --------------------\nconst parseCSV = (csvText, options = {}) => {\n  // options: sgWindow, sgPoly, baselineN, skipStart, skipEnd\n  const sgWindow = options.sgWindow || 31;\n  const sgPoly = options.sgPoly || 3;\n  const baselineN = options.baselineN || 2000;\n  const skipStart = options.skipStart || 6650;\n  const skipEnd = options.skipEnd || 27000;\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = [];\n  const interf = [];\n  let dataStarted = false;\n  let lineCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n    if (dataStarted) {\n      lineCount++;\n      if (lineCount < skipStart) continue;\n      if (lineCount > skipEnd) break;\n      const fields = line.split(\",\");\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]);\n        const ch1Val = parseFloat(fields[1]);\n        const ch3Val = parseFloat(fields[3]);\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n\n  // 1) Сглаживаем (SG — как в Origin)\n  const interfSmoothed = savitzkyGolay(interf, sgWindow, sgPoly);\n\n  // 2) Удаляем baseline из сглаженного сигнала (чтобы центрировать)\n  const interfCorrected = removeBaseline(interfSmoothed, baselineN);\n\n  // 3) Находим нулевые пересечения на скорректированном сигнале\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interfCorrected);\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePoints(t0, y0, 100e-9);\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivative(filteredT0);\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interfCorrected);\n  return {\n    t,\n    tenz,\n    interf,\n    // оригинальный CH3 (с добавленным +0.04)\n    interfSmoothed,\n    interfCorrected,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints\n  };\n};\n\n// -------------------- Поиск нулевых пересечений --------------------\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n  if (!t || !interf) return {\n    t0,\n    y0\n  };\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n    const x1 = t[i - 1];\n    const x2 = t[i];\n\n    // если точка действительно почти ноль — фиксируем её\n    if (Math.abs(y1) < eps) {\n      t0.push(x1);\n      y0.push(0);\n      continue;\n    }\n    if (Math.abs(y2) < eps) {\n      t0.push(x2);\n      y0.push(0);\n      continue;\n    }\n\n    // если обе около нуля (плато)\n    if (Math.abs(y1) < eps && Math.abs(y2) < eps) {\n      t0.push((x1 + x2) / 2);\n      y0.push(0);\n      continue;\n    }\n\n    // если есть смена знака — линейная интерполяция для точного времени\n    if (y1 * y2 < 0) {\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\n\n// -------------------- Фильтрация близких точек --------------------\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (!Array.isArray(t0) || t0.length <= 1) {\n    return {\n      filteredT0: t0 || [],\n      filteredY0: y0 || []\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\n\n// -------------------- Расчёт производной по временам t0 --------------------\nconst calculateDerivative = t0 => {\n  const u_interf = [];\n  const dudt_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\n\n// -------------------- Поиск пересечений двух сигналов (tenz vs interf) --------------------\nconst findSignalIntersectionsAtZero = (t, tenz, interf, yThreshold = 0.02) => {\n  const intersections = [];\n  if (!t || !tenz || !interf) return intersections;\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = tenz[i - 1] - interf[i - 1];\n    const diffCurr = tenz[i] - interf[i];\n    if (diffPrev <= 0 && diffCurr > 0 || diffPrev >= 0 && diffCurr < 0) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n      if (diffDelta === 0) continue;\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n      const tenzValue = tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\n      const interfValue = interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\n      const value = (tenzValue + interfValue) / 2;\n      if (Math.abs(value) <= yThreshold) {\n        intersections.push({\n          time,\n          value\n        });\n      }\n    }\n  }\n  return intersections;\n};\n\n// -------------------- Подготовка данных для графиков --------------------\nexport const generateChartData = results => {\n  const {\n    t,\n    tenz,\n    interf,\n    // original (with +0.04)\n    interfSmoothed,\n    interfCorrected,\n    t0,\n    dudt_interf,\n    intersectionPoints\n  } = results;\n  const step = Math.max(1, Math.floor(t.length / 2000));\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  const limitedInterfSmoothed = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interfCorrected[i]);\n    limitedInterfSmoothed.push(interfSmoothed[i]);\n  }\n  const chartData = {\n    original: [{\n      label: \"Тензометрический сигнал (CH1)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedTenz[idx]\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал (CH3, сглаженный SG)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterfSmoothed[idx]\n      })),\n      borderColor: \"rgb(0, 0, 0)\",\n      backgroundColor: \"rgba(0, 0, 0, 0.05)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал (CH3, центрированный)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterf[idx]\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }],\n    processed: [{\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time - 51.5e-6,\n        y: dudt_interf[idx]\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    }, {\n      label: \"Скорректированный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + 50e-6,\n        y: -limitedTenz[idx] * 5000 + 0.38\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }]\n  };\n  if (intersectionPoints && intersectionPoints.length) {\n    chartData.original.push({\n      label: \"Пересечения при Y=0\",\n      data: intersectionPoints.map(({\n        time,\n        value\n      }) => ({\n        x: time,\n        y: value\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 3,\n      pointHoverRadius: 4,\n      borderWidth: 0,\n      order: 99,\n      z: 50,\n      intersectionMarker: true,\n      markerSize: 4,\n      markerColor: \"#000000\",\n      markerAlpha: 0.7,\n      markerLineWidth: 2\n    });\n  }\n  chartData.intersections = intersectionPoints || [];\n  chartData.rawData = {\n    t: limitedT,\n    tenz: limitedTenz,\n    interf: limitedInterf,\n    fullT: t,\n    fullTenz: tenz,\n    fullInterf: interfCorrected,\n    t0,\n    dudt_interf\n  };\n  return chartData;\n};","map":{"version":3,"names":["processCSVData","file","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","transpose","M","map","_","i","row","multiplyMatrices","A","B","aRows","length","aCols","bCols","C","Array","from","fill","k","v","j","invertMatrix","m","n","concat","maxRow","Math","abs","tmp","diag","factor","slice","savitzkyGolay","data","windowSize","polyOrder","isArray","max","floor","out","half","sum","cnt","idx","min","p","push","pow","AT","ATA","invATA","err","ATAinvAT","coeffs","acc","removeBaseline","arr","N","count","avg","reduce","s","options","sgWindow","sgPoly","baselineN","skipStart","skipEnd","lines","split","t","tenz","interf","dataStarted","lineCount","line","trim","startsWith","fields","timeVal","parseFloat","ch1Val","ch3Val","isNaN","interfSmoothed","interfCorrected","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePoints","u_interf","dudt_interf","calculateDerivative","intersectionPoints","findSignalIntersectionsAtZero","eps","y1","y2","x1","x2","t_zero","minDistance","newT0","newY0","du_interf","dt_interf","yThreshold","intersections","diffPrev","diffCurr","t1","t2","diffDelta","ratio","time","tenzValue","interfValue","value","generateChartData","step","limitedT","limitedTenz","limitedInterf","limitedInterfSmoothed","chartData","original","label","x","y","borderColor","backgroundColor","borderWidth","tension","processed","pointRadius","showLine","pointStyle","pointHoverRadius","order","z","intersectionMarker","markerSize","markerColor","markerAlpha","markerLineWidth","rawData","fullT","fullTenz","fullInterf"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["// Полный обновлённый файл — Savitzky-Golay (без внешних библиотек), baseline removal,\n// сглаживание, поиск нулевых пересечений, фильтрация близких точек и подготовка данных для графиков.\n\nexport const processCSVData = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\n// -------------------- Утилиты для матриц (используются для SG) --------------------\nconst transpose = (M) => M[0].map((_, i) => M.map(row => row[i]));\n\nconst multiplyMatrices = (A, B) => {\n  const aRows = A.length, aCols = A[0].length, bCols = B[0].length;\n  const C = Array.from({ length: aRows }, () => Array(bCols).fill(0));\n  for (let i = 0; i < aRows; i++) {\n    for (let k = 0; k < aCols; k++) {\n      const v = A[i][k];\n      for (let j = 0; j < bCols; j++) {\n        C[i][j] += v * B[k][j];\n      }\n    }\n  }\n  return C;\n};\n\nconst invertMatrix = (m) => {\n  const n = m.length;\n  // Создаём расширенную матрицу [m | I]\n  const A = m.map((row, i) => row.concat(\n    Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))\n  ));\n  // Прямой ход\n  for (let i = 0; i < n; i++) {\n    // Находим максимальный по модулю элемент в столбце (для устойчивости)\n    let maxRow = i;\n    for (let k = i + 1; k < n; k++) {\n      if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;\n    }\n    if (Math.abs(A[maxRow][i]) < 1e-15) {\n      throw new Error(\"Матрица вырождена, невозможно инвертировать\");\n    }\n    // Меняем строки\n    if (maxRow !== i) {\n      const tmp = A[i];\n      A[i] = A[maxRow];\n      A[maxRow] = tmp;\n    }\n    // Нормируем строку\n    const diag = A[i][i];\n    for (let j = 0; j < 2 * n; j++) A[i][j] /= diag;\n    // Исключаем ниже\n    for (let k = 0; k < n; k++) {\n      if (k === i) continue;\n      const factor = A[k][i];\n      if (factor === 0) continue;\n      for (let j = 0; j < 2 * n; j++) {\n        A[k][j] -= factor * A[i][j];\n      }\n    }\n  }\n  // Извлекаем правую половину — обратную матрицу\n  return A.map(row => row.slice(n));\n};\n\n// -------------------- Savitzky–Golay фильтр (реализация без зависимостей) --------------------\nconst savitzkyGolay = (data, windowSize = 31, polyOrder = 3) => {\n  // Параметры sanity\n  if (!Array.isArray(data) || data.length === 0) return [];\n  windowSize = Math.max(3, Math.floor(windowSize));\n  if (windowSize % 2 === 0) windowSize += 1;\n  polyOrder = Math.max(1, Math.floor(polyOrder));\n  if (polyOrder >= windowSize) polyOrder = windowSize - 1;\n\n  const n = data.length;\n  if (n <= windowSize) {\n    // Если данных меньше окна — возвращаем простое сглаживание (скользящее среднее)\n    const out = new Array(n).fill(0);\n    const half = Math.floor(windowSize / 2);\n    for (let i = 0; i < n; i++) {\n      let sum = 0, cnt = 0;\n      for (let j = i - half; j <= i + half; j++) {\n        const idx = Math.min(n - 1, Math.max(0, j));\n        sum += data[idx];\n        cnt++;\n      }\n      out[i] = sum / cnt;\n    }\n    return out;\n  }\n\n  const half = Math.floor(windowSize / 2);\n\n  // Строим матрицу A размера windowSize x (polyOrder+1)\n  const A = [];\n  for (let i = -half; i <= half; i++) {\n    const row = [];\n    for (let p = 0; p <= polyOrder; p++) row.push(Math.pow(i, p));\n    A.push(row);\n  }\n\n  const AT = transpose(A);\n  const ATA = multiplyMatrices(AT, A);\n\n  // Инвертируем ATA\n  let invATA;\n  try {\n    invATA = invertMatrix(ATA);\n  } catch (err) {\n    // В случае проблем с инверсией возвращаем 원본\n    return data.slice();\n  }\n\n  // ATA^{-1} * AT  -> матрица (polyOrder+1) x windowSize\n  const ATAinvAT = multiplyMatrices(invATA, AT);\n\n  // Коэффициенты для сглаживания центральной точки — это row 0 (нольй порядок)\n  // Фактически нам нужны веса w_j так, что smoothed[i] = sum_j w_j * data[i+j-half]\n  const coeffs = ATAinvAT[0]; // длина = windowSize\n\n  // Применяем свёртку с коэффициентами, на границах репликация краевых значений\n  const out = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    let acc = 0;\n    for (let j = -half; j <= half; j++) {\n      let idx = i + j;\n      if (idx < 0) idx = 0;\n      if (idx >= n) idx = n - 1;\n      acc += data[idx] * coeffs[j + half];\n    }\n    out[i] = acc;\n  }\n\n  return out;\n};\n\n// -------------------- Baseline removal --------------------\nconst removeBaseline = (arr, N = 2000) => {\n  if (!Array.isArray(arr) || arr.length === 0) return [];\n  const count = Math.min(arr.length, N);\n  const avg = arr.slice(0, count).reduce((s, v) => s + v, 0) / count;\n  return arr.map(v => v - avg);\n};\n\n// -------------------- Парсинг CSV и основной поток --------------------\nconst parseCSV = (csvText, options = {}) => {\n  // options: sgWindow, sgPoly, baselineN, skipStart, skipEnd\n  const sgWindow = options.sgWindow || 31;\n  const sgPoly = options.sgPoly || 3;\n  const baselineN = options.baselineN || 2000;\n  const skipStart = options.skipStart || 6650;\n  const skipEnd = options.skipEnd || 27000;\n\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = [];\n  const interf = [];\n\n  let dataStarted = false;\n  let lineCount = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n\n    if (dataStarted) {\n      lineCount++;\n\n      if (lineCount < skipStart) continue;\n      if (lineCount > skipEnd) break;\n\n      const fields = line.split(\",\");\n\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]);\n        const ch1Val = parseFloat(fields[1]);\n        const ch3Val = parseFloat(fields[3]);\n\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n\n  // 1) Сглаживаем (SG — как в Origin)\n  const interfSmoothed = savitzkyGolay(interf, sgWindow, sgPoly);\n\n  // 2) Удаляем baseline из сглаженного сигнала (чтобы центрировать)\n  const interfCorrected = removeBaseline(interfSmoothed, baselineN);\n\n  // 3) Находим нулевые пересечения на скорректированном сигнале\n  const { t0, y0 } = findZeroCrossings(t, interfCorrected);\n  const { filteredT0, filteredY0 } = filterClosePoints(t0, y0, 100e-9);\n  const { u_interf, dudt_interf } = calculateDerivative(filteredT0);\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interfCorrected);\n\n  return {\n    t,\n    tenz,\n    interf, // оригинальный CH3 (с добавленным +0.04)\n    interfSmoothed,\n    interfCorrected,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints,\n  };\n};\n\n// -------------------- Поиск нулевых пересечений --------------------\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n\n  if (!t || !interf) return { t0, y0 };\n\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n    const x1 = t[i - 1];\n    const x2 = t[i];\n\n    // если точка действительно почти ноль — фиксируем её\n    if (Math.abs(y1) < eps) {\n      t0.push(x1);\n      y0.push(0);\n      continue;\n    }\n    if (Math.abs(y2) < eps) {\n      t0.push(x2);\n      y0.push(0);\n      continue;\n    }\n\n    // если обе около нуля (плато)\n    if (Math.abs(y1) < eps && Math.abs(y2) < eps) {\n      t0.push((x1 + x2) / 2);\n      y0.push(0);\n      continue;\n    }\n\n    // если есть смена знака — линейная интерполяция для точного времени\n    if (y1 * y2 < 0) {\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n\n  return { t0, y0 };\n};\n\n// -------------------- Фильтрация близких точек --------------------\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (!Array.isArray(t0) || t0.length <= 1) {\n    return { filteredT0: t0 || [], filteredY0: y0 || [] };\n  }\n\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    if (newT0.length === filteredT0.length) break;\n\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n\n  return { filteredT0, filteredY0 };\n};\n\n// -------------------- Расчёт производной по временам t0 --------------------\nconst calculateDerivative = (t0) => {\n  const u_interf = [];\n  const dudt_interf = [];\n\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = (0.63 / 4) * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + (0.63 / 4) * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n\n  return { u_interf, dudt_interf };\n};\n\n// -------------------- Поиск пересечений двух сигналов (tenz vs interf) --------------------\nconst findSignalIntersectionsAtZero = (t, tenz, interf, yThreshold = 0.02) => {\n  const intersections = [];\n  if (!t || !tenz || !interf) return intersections;\n\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = tenz[i - 1] - interf[i - 1];\n    const diffCurr = tenz[i] - interf[i];\n\n    if ((diffPrev <= 0 && diffCurr > 0) || (diffPrev >= 0 && diffCurr < 0)) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n\n      if (diffDelta === 0) continue;\n\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n\n      const tenzValue = tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\n      const interfValue = interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\n\n      const value = (tenzValue + interfValue) / 2;\n\n      if (Math.abs(value) <= yThreshold) {\n        intersections.push({ time, value });\n      }\n    }\n  }\n\n  return intersections;\n};\n\n// -------------------- Подготовка данных для графиков --------------------\nexport const generateChartData = (results) => {\n  const {\n    t,\n    tenz,\n    interf, // original (with +0.04)\n    interfSmoothed,\n    interfCorrected,\n    t0,\n    dudt_interf,\n    intersectionPoints\n  } = results;\n\n  const step = Math.max(1, Math.floor(t.length / 2000));\n\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  const limitedInterfSmoothed = [];\n\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interfCorrected[i]);\n    limitedInterfSmoothed.push(interfSmoothed[i]);\n  }\n\n  const chartData = {\n    original: [\n      {\n        label: \"Тензометрический сигнал (CH1)\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedTenz[idx] })),\n        borderColor: \"rgb(255, 99, 132)\",\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n      {\n        label: \"Интерферометрический сигнал (CH3, сглаженный SG)\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterfSmoothed[idx] })),\n        borderColor: \"rgb(0, 0, 0)\",\n        backgroundColor: \"rgba(0, 0, 0, 0.05)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n      {\n        label: \"Интерферометрический сигнал (CH3, центрированный)\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterf[idx] })),\n        borderColor: \"rgb(54, 162, 235)\",\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n    ],\n    processed: [\n      {\n        label: \"Производная интерферометрического сигнала\",\n        data: t0.map((time, idx) => ({\n          x: time - 51.5e-6,\n          y: dudt_interf[idx],\n        })),\n        borderColor: \"rgb(75, 192, 192)\",\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n        borderWidth: 2,\n        pointRadius: 2,\n        showLine: true,\n      },\n      {\n        label: \"Скорректированный тензосигнал\",\n        data: limitedT.map((time, idx) => ({\n          x: time + 50e-6,\n          y: -limitedTenz[idx] * 5000 + 0.38,\n        })),\n        borderColor: \"rgb(153, 102, 255)\",\n        backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n    ],\n  };\n\n  if (intersectionPoints && intersectionPoints.length) {\n    chartData.original.push({\n      label: \"Пересечения при Y=0\",\n      data: intersectionPoints.map(({ time, value }) => ({ x: time, y: value })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 3,\n      pointHoverRadius: 4,\n      borderWidth: 0,\n      order: 99,\n      z: 50,\n      intersectionMarker: true,\n      markerSize: 4,\n      markerColor: \"#000000\",\n      markerAlpha: 0.7,\n      markerLineWidth: 2,\n    });\n  }\n\n  chartData.intersections = intersectionPoints || [];\n\n  chartData.rawData = {\n    t: limitedT,\n    tenz: limitedTenz,\n    interf: limitedInterf,\n    fullT: t,\n    fullTenz: tenz,\n    fullInterf: interfCorrected,\n    t0,\n    dudt_interf,\n  };\n\n  return chartData;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}