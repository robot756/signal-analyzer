{"ast":null,"code":"export const processCSVData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\nconst parseCSV = csvText => {\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = []; // CH1 - тензометрический сигнал\n  const interf = []; // CH3 - интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки и заголовки\n    if (!line) continue;\n\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\n      if (lineCount < 6650) continue;\n      if (lineCount > 27000) break;\n      const fields = line.split(\",\");\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]); // TIME\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\n\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          // Добавляем смещение как в оригинале: +0.04\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n  console.log(`Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`);\n  console.log(\"Первые значения:\", {\n    t: t.slice(0, 5),\n    tenz: tenz.slice(0, 5),\n    interf: interf.slice(0, 5)\n  });\n\n  // Поиск нулевых пересечений\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interf);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePoints(t0, y0, 100e-9);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivative(filteredT0);\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interf);\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints\n  };\n};\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n    const x1 = t[i - 1];\n    const x2 = t[i];\n\n    // 1) Если точно попали в ноль\n    if (Math.abs(y1) < eps) {\n      t0.push(x1);\n      y0.push(0);\n      continue;\n    }\n    if (Math.abs(y2) < eps) {\n      t0.push(x2);\n      y0.push(0);\n      continue;\n    }\n\n    // 2) Если обе около нуля (плато)\n    if (Math.abs(y1) < eps && Math.abs(y2) < eps) {\n      t0.push((x1 + x2) / 2);\n      y0.push(0);\n      continue;\n    }\n\n    // 3) Смена знака вокруг нуля\n    if (y1 * y2 < 0) {\n      // Линейная интерполяция: точное время перехода\n      const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n      t0.push(t_zero);\n      y0.push(0);\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (t0.length <= 1) {\n    return {\n      filteredT0: t0,\n      filteredY0: y0\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  // Многократная фильтрация (k < 10 как в оригинале)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\nconst calculateDerivative = t0 => {\n  const u_interf = [];\n  const dudt_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\nconst findSignalIntersectionsAtZero = (t, tenz, interf, yThreshold = 0.02) => {\n  const intersections = [];\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = tenz[i - 1] - interf[i - 1];\n    const diffCurr = tenz[i] - interf[i];\n    if (diffPrev <= 0 && diffCurr > 0 || diffPrev >= 0 && diffCurr < 0) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n      if (diffDelta === 0) continue;\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n      const tenzValue = tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\n      const interfValue = interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\n\n      // среднее (они почти равны)\n      const value = (tenzValue + interfValue) / 2;\n      if (Math.abs(value) <= yThreshold) {\n        intersections.push({\n          time,\n          value\n        });\n      }\n    }\n  }\n  return intersections;\n};\nexport const generateChartData = results => {\n  const {\n    t,\n    tenz,\n    interf,\n    t0,\n    dudt_interf,\n    intersectionPoints\n  } = results;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / 2000));\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // Подготавливаем данные для графиков\n  const chartData = {\n    original: [{\n      label: \"Тензометрический сигнал (CH1)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedTenz[idx]\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал (CH3)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterf[idx]\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }],\n    processed: [{\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time - 51.5e-6,\n        // коррекция времени\n        y: dudt_interf[idx]\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    }, {\n      label: \"Скорректированный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + 50e-6,\n        // коррекция времени\n        y: -limitedTenz[idx] * 5000 + 0.38 // преобразование\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }]\n  };\n  if (intersectionPoints.length) {\n    chartData.original.push({\n      label: \"Пересечения при Y=0\",\n      data: intersectionPoints.map(({\n        time,\n        value\n      }) => ({\n        x: time,\n        y: value\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 0,\n      pointHoverRadius: 0,\n      borderWidth: 0,\n      order: 99,\n      z: 50,\n      intersectionMarker: true,\n      markerSize: 4,\n      markerColor: \"#000000\",\n      markerAlpha: 0.7,\n      markerLineWidth: 2\n    });\n  }\n  chartData.intersections = intersectionPoints;\n\n  // Сохраняем исходные данные для пересчета при сдвиге\n  chartData.rawData = {\n    t: limitedT,\n    tenz: limitedTenz,\n    interf: limitedInterf,\n    fullT: t,\n    fullTenz: tenz,\n    fullInterf: interf,\n    t0,\n    dudt_interf\n  };\n  console.log(\"Данные для графиков подготовлены\");\n  return chartData;\n};","map":{"version":3,"names":["processCSVData","file","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","lines","split","t","tenz","interf","dataStarted","lineCount","i","length","line","trim","startsWith","fields","timeVal","parseFloat","ch1Val","ch3Val","isNaN","push","console","log","slice","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePoints","u_interf","dudt_interf","calculateDerivative","intersectionPoints","findSignalIntersectionsAtZero","eps","y1","y2","x1","x2","Math","abs","t_zero","minDistance","k","newT0","newY0","du_interf","dt_interf","yThreshold","intersections","diffPrev","diffCurr","t1","t2","diffDelta","ratio","time","tenzValue","interfValue","value","generateChartData","step","max","floor","limitedT","limitedTenz","limitedInterf","chartData","original","label","data","map","idx","x","y","borderColor","backgroundColor","borderWidth","tension","processed","pointRadius","showLine","pointStyle","pointHoverRadius","order","z","intersectionMarker","markerSize","markerColor","markerAlpha","markerLineWidth","rawData","fullT","fullTenz","fullInterf"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["export const processCSVData = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\n\nconst parseCSV = (csvText) => {\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = []; // CH1 - тензометрический сигнал\n  const interf = []; // CH3 - интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки и заголовки\n    if (!line) continue;\n\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\n      if (lineCount < 6650) continue;\n      if (lineCount > 27000) break;\n\n      const fields = line.split(\",\");\n\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]); // TIME\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\n\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          // Добавляем смещение как в оригинале: +0.04\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n\n  console.log(\n    `Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`\n  );\n  console.log(\"Первые значения:\", {\n    t: t.slice(0, 5),\n    tenz: tenz.slice(0, 5),\n    interf: interf.slice(0, 5),\n  });\n\n  // Поиск нулевых пересечений\n  const { t0, y0 } = findZeroCrossings(t, interf);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const { filteredT0, filteredY0 } = filterClosePoints(t0, y0, 100e-9);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const { u_interf, dudt_interf } = calculateDerivative(filteredT0);\n  const intersectionPoints = findSignalIntersectionsAtZero(t, tenz, interf);\n\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf,\n    intersectionPoints,\n  };\n};\n\nconst findZeroCrossings = (t, interf, eps = 1e-6) => {\n  const t0 = [];\n  const y0 = [];\n\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n    const x1 = t[i - 1];\n    const x2 = t[i];\n\n    // 1) Если точно попали в ноль\n    if (Math.abs(y1) < eps) {\n      t0.push(x1);\n      y0.push(0);\n      continue;\n    }\n    if (Math.abs(y2) < eps) {\n      t0.push(x2);\n      y0.push(0);\n      continue;\n    }\n\n    // 2) Если обе около нуля (плато)\n    if (Math.abs(y1) < eps && Math.abs(y2) < eps) {\n      t0.push((x1 + x2) / 2);\n      y0.push(0);\n      continue;\n    }\n\n    // 3) Смена знака вокруг нуля\n    if (y1 * y2 < 0) {\n      // Линейная интерполяция: точное время перехода\n      const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n      t0.push(t_zero);\n      y0.push(0);\n    }\n  }\n\n  return { t0, y0 };\n};\n\n\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (t0.length <= 1) {\n    return { filteredT0: t0, filteredY0: y0 };\n  }\n\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  // Многократная фильтрация (k < 10 как в оригинале)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n\n  return { filteredT0, filteredY0 };\n};\n\nconst calculateDerivative = (t0) => {\n  const u_interf = [];\n  const dudt_interf = [];\n\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = (0.63 / 4) * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + (0.63 / 4) * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n\n  return { u_interf, dudt_interf };\n};\n\nconst findSignalIntersectionsAtZero = (\n  t,\n  tenz,\n  interf,\n  yThreshold = 0.02\n) => {\n  const intersections = [];\n\n  for (let i = 1; i < t.length; i++) {\n    const diffPrev = tenz[i - 1] - interf[i - 1];\n    const diffCurr = tenz[i] - interf[i];\n\n    if ((diffPrev <= 0 && diffCurr > 0) || (diffPrev >= 0 && diffCurr < 0)) {\n      const t1 = t[i - 1];\n      const t2 = t[i];\n      const diffDelta = diffCurr - diffPrev;\n\n      if (diffDelta === 0) continue;\n\n      const ratio = -diffPrev / diffDelta;\n      const time = t1 + ratio * (t2 - t1);\n\n      const tenzValue =\n        tenz[i - 1] + ratio * (tenz[i] - tenz[i - 1]);\n      const interfValue =\n        interf[i - 1] + ratio * (interf[i] - interf[i - 1]);\n\n      // среднее (они почти равны)\n      const value = (tenzValue + interfValue) / 2;\n\n      if (Math.abs(value) <= yThreshold) {\n        intersections.push({ time, value });\n      }\n    }\n  }\n\n  return intersections;\n};\n\nexport const generateChartData = (results) => {\n  const { t, tenz, interf, t0, dudt_interf, intersectionPoints } = results;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / 2000));\n\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // Подготавливаем данные для графиков\n  const chartData = {\n    original: [\n      {\n        label: \"Тензометрический сигнал (CH1)\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedTenz[idx] })),\n        borderColor: \"rgb(255, 99, 132)\",\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n      {\n        label: \"Интерферометрический сигнал (CH3)\",\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterf[idx] })),\n        borderColor: \"rgb(54, 162, 235)\",\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n    ],\n    processed: [\n      {\n        label: \"Производная интерферометрического сигнала\",\n        data: t0.map((time, idx) => ({\n          x: time - 51.5e-6, // коррекция времени\n          y: dudt_interf[idx],\n        })),\n        borderColor: \"rgb(75, 192, 192)\",\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n        borderWidth: 2,\n        pointRadius: 2,\n        showLine: true,\n      },\n      {\n        label: \"Скорректированный тензосигнал\",\n        data: limitedT.map((time, idx) => ({\n          x: time + 50e-6, // коррекция времени\n          y: -limitedTenz[idx] * 5000 + 0.38, // преобразование\n        })),\n        borderColor: \"rgb(153, 102, 255)\",\n        backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n        borderWidth: 1,\n        tension: 0.1,\n      },\n    ],\n  };\n\n  if (intersectionPoints.length) {\n    chartData.original.push({\n      label: \"Пересечения при Y=0\",\n      data: intersectionPoints.map(({ time, value }) => ({\n        x: time,\n        y: value,\n      })),\n      showLine: false,\n      pointStyle: \"crossRot\",\n      pointRadius: 0,\n      pointHoverRadius: 0,\n      borderWidth: 0,\n      order: 99,\n      z: 50,\n      intersectionMarker: true,\n      markerSize: 4,\n      markerColor: \"#000000\",\n      markerAlpha: 0.7,\n      markerLineWidth: 2,\n    });\n  }\n\n  chartData.intersections = intersectionPoints;\n  \n  // Сохраняем исходные данные для пересчета при сдвиге\n  chartData.rawData = {\n    t: limitedT,\n    tenz: limitedTenz,\n    interf: limitedInterf,\n    fullT: t,\n    fullTenz: tenz,\n    fullInterf: interf,\n    t0,\n    dudt_interf,\n  };\n\n  console.log(\"Данные для графиков подготовлены\");\n\n  return chartData;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}