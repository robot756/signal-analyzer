{"ast":null,"code":"export const processCSVData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const csvText = e.target.result;\n        const results = parseCSV(csvText);\n        resolve(results);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\n    reader.readAsText(file);\n  });\n};\nconst parseCSV = csvText => {\n  const lines = csvText.split(\"\\n\");\n  const t = [];\n  const tenz = []; // CH1 - тензометрический сигнал\n  const interf = []; // CH3 - интерферометрический сигнал\n\n  let dataStarted = false;\n  let lineCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Пропускаем пустые строки и заголовки\n    if (!line) continue;\n\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\n    if (line.startsWith(\"TIME,CH1,\")) {\n      dataStarted = true;\n      continue;\n    }\n\n    // Если нашли начало данных, начинаем парсить\n    if (dataStarted) {\n      lineCount++;\n\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\n      if (lineCount < 6650) continue;\n      if (lineCount > 27000) break;\n      const fields = line.split(\",\");\n      if (fields.length >= 5) {\n        const timeVal = parseFloat(fields[0]); // TIME\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\n\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\n          t.push(timeVal);\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\n          tenz.push(ch1Val * 0.00132 * 1.25);\n          // Добавляем смещение как в оригинале: +0.04\n          interf.push(ch3Val + 0.04);\n        }\n      }\n    }\n  }\n  console.log(`Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`);\n  console.log(\"Первые значения:\", {\n    t: t.slice(0, 5),\n    tenz: tenz.slice(0, 5),\n    interf: interf.slice(0, 5)\n  });\n\n  // Поиск нулевых пересечений\n  const {\n    t0,\n    y0\n  } = findZeroCrossings(t, interf);\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\n\n  // Фильтрация близких точек\n  const {\n    filteredT0,\n    filteredY0\n  } = filterClosePoints(t0, y0, 100e-9);\n  console.log(`После фильтрации: ${filteredT0.length}`);\n\n  // Расчет производной\n  const {\n    u_interf,\n    dudt_interf\n  } = calculateDerivative(filteredT0);\n  return {\n    t,\n    tenz,\n    interf,\n    t0: filteredT0,\n    y0: filteredY0,\n    u_interf,\n    dudt_interf\n  };\n};\nconst findZeroCrossings = (t, interf) => {\n  const t0 = [];\n  const y0 = [];\n  for (let i = 1; i < interf.length; i++) {\n    const y1 = interf[i - 1];\n    const y2 = interf[i];\n\n    // Проверяем пересечение нуля\n    if (y1 <= 0 && y2 > 0 || y1 >= 0 && y2 < 0) {\n      const x1 = t[i - 1];\n      const x2 = t[i];\n\n      // Линейная интерполяция для точного определения точки пересечения\n      if (y2 !== y1) {\n        const t_zero = x1 - y1 * (x2 - x1) / (y2 - y1);\n        t0.push(t_zero);\n        y0.push(0);\n      }\n    }\n  }\n  return {\n    t0,\n    y0\n  };\n};\nconst filterClosePoints = (t0, y0, minDistance) => {\n  if (t0.length <= 1) {\n    return {\n      filteredT0: t0,\n      filteredY0: y0\n    };\n  }\n  let filteredT0 = [...t0];\n  let filteredY0 = [...y0];\n\n  // Многократная фильтрация (k < 10 как в оригинале)\n  for (let k = 0; k < 10; k++) {\n    const newT0 = [filteredT0[0]];\n    const newY0 = [filteredY0[0]];\n    for (let i = 1; i < filteredT0.length; i++) {\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\n        newT0.push(filteredT0[i]);\n        newY0.push(filteredY0[i]);\n      }\n    }\n\n    // Если количество точек не изменилось, выходим\n    if (newT0.length === filteredT0.length) break;\n    filteredT0 = newT0;\n    filteredY0 = newY0;\n  }\n  return {\n    filteredT0,\n    filteredY0\n  };\n};\nconst calculateDerivative = t0 => {\n  const u_interf = [];\n  const dudt_interf = [];\n  for (let i = 0; i < t0.length; i++) {\n    if (i === 0) {\n      u_interf[i] = 0.63 / 4 * 1e-6;\n      dudt_interf[i] = 0;\n    } else {\n      u_interf[i] = u_interf[i - 1] + 0.63 / 4 * 1e-6;\n      const du_interf = u_interf[i] - u_interf[i - 1];\n      const dt_interf = t0[i] - t0[i - 1];\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\n    }\n  }\n  return {\n    u_interf,\n    dudt_interf\n  };\n};\nexport const generateChartData = results => {\n  const {\n    t,\n    tenz,\n    interf,\n    t0,\n    dudt_interf\n  } = results;\n\n  // Ограничиваем количество точек для производительности\n  const step = Math.max(1, Math.floor(t.length / 2000));\n  const limitedT = [];\n  const limitedTenz = [];\n  const limitedInterf = [];\n  for (let i = 0; i < t.length; i += step) {\n    limitedT.push(t[i]);\n    limitedTenz.push(tenz[i]);\n    limitedInterf.push(interf[i]);\n  }\n\n  // Подготавливаем данные для графиков\n  const chartData = {\n    original: [{\n      label: \"Тензометрический сигнал (CH1)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedTenz[idx]\n      })),\n      borderColor: \"rgb(255, 99, 132)\",\n      backgroundColor: \"rgba(255, 99, 132, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }, {\n      label: \"Интерферометрический сигнал (CH3)\",\n      data: limitedT.map((time, idx) => ({\n        x: time,\n        y: limitedInterf[idx]\n      })),\n      borderColor: \"rgb(54, 162, 235)\",\n      backgroundColor: \"rgba(54, 162, 235, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }],\n    processed: [{\n      label: \"Производная интерферометрического сигнала\",\n      data: t0.map((time, idx) => ({\n        x: time - 51.5e-6,\n        // коррекция времени\n        y: dudt_interf[idx]\n      })),\n      borderColor: \"rgb(75, 192, 192)\",\n      backgroundColor: \"rgba(75, 192, 192, 0.1)\",\n      borderWidth: 2,\n      pointRadius: 2,\n      showLine: true\n    }, {\n      label: \"Скорректированный тензосигнал\",\n      data: limitedT.map((time, idx) => ({\n        x: time + 50e-6,\n        // коррекция времени\n        y: -limitedTenz[idx] * 5000 + 0.38 // преобразование\n      })),\n      borderColor: \"rgb(153, 102, 255)\",\n      backgroundColor: \"rgba(153, 102, 255, 0.1)\",\n      borderWidth: 1,\n      tension: 0.1\n    }]\n  };\n  console.log(\"Данные для графиков подготовлены\");\n  return chartData;\n};","map":{"version":3,"names":["processCSVData","file","Promise","resolve","reject","reader","FileReader","onload","e","csvText","target","result","results","parseCSV","error","onerror","Error","readAsText","lines","split","t","tenz","interf","dataStarted","lineCount","i","length","line","trim","startsWith","fields","timeVal","parseFloat","ch1Val","ch3Val","isNaN","push","console","log","slice","t0","y0","findZeroCrossings","filteredT0","filteredY0","filterClosePoints","u_interf","dudt_interf","calculateDerivative","y1","y2","x1","x2","t_zero","minDistance","k","newT0","newY0","du_interf","dt_interf","generateChartData","step","Math","max","floor","limitedT","limitedTenz","limitedInterf","chartData","original","label","data","map","time","idx","x","y","borderColor","backgroundColor","borderWidth","tension","processed","pointRadius","showLine"],"sources":["C:/Users/Иван/Desktop/signal-analyzer/src/csvProcessor.js"],"sourcesContent":["export const processCSVData = (file) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n\r\n    reader.onload = (e) => {\r\n      try {\r\n        const csvText = e.target.result;\r\n        const results = parseCSV(csvText);\r\n        resolve(results);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n\r\n    reader.onerror = () => reject(new Error(\"Ошибка чтения файла\"));\r\n    reader.readAsText(file);\r\n  });\r\n};\r\n\r\nconst parseCSV = (csvText) => {\r\n  const lines = csvText.split(\"\\n\");\r\n  const t = [];\r\n  const tenz = []; // CH1 - тензометрический сигнал\r\n  const interf = []; // CH3 - интерферометрический сигнал\r\n\r\n  let dataStarted = false;\r\n  let lineCount = 0;\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i].trim();\r\n\r\n    // Пропускаем пустые строки и заголовки\r\n    if (!line) continue;\r\n\r\n    // Ищем начало данных (строка с \"TIME,CH1,...\")\r\n    if (line.startsWith(\"TIME,CH1,\")) {\r\n      dataStarted = true;\r\n      continue;\r\n    }\r\n\r\n    // Если нашли начало данных, начинаем парсить\r\n    if (dataStarted) {\r\n      lineCount++;\r\n\r\n      // Пропускаем начальные строки (6650-27000 как в оригинале)\r\n      if (lineCount < 6650) continue;\r\n      if (lineCount > 27000) break;\r\n\r\n      const fields = line.split(\",\");\r\n\r\n      if (fields.length >= 5) {\r\n        const timeVal = parseFloat(fields[0]); // TIME\r\n        const ch1Val = parseFloat(fields[1]); // CH1 - тензосигнал\r\n        const ch3Val = parseFloat(fields[3]); // CH3 - интерферометр\r\n\r\n        if (!isNaN(timeVal) && !isNaN(ch1Val) && !isNaN(ch3Val)) {\r\n          t.push(timeVal);\r\n          // Применяем коэффициенты как в оригинальном коде: *0.00132*1.25\r\n          tenz.push(ch1Val * 0.00132 * 1.25);\r\n          // Добавляем смещение как в оригинале: +0.04\r\n          interf.push(ch3Val + 0.04);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(\r\n    `Прочитано данных: t=${t.length}, tenz=${tenz.length}, interf=${interf.length}`\r\n  );\r\n  console.log(\"Первые значения:\", {\r\n    t: t.slice(0, 5),\r\n    tenz: tenz.slice(0, 5),\r\n    interf: interf.slice(0, 5),\r\n  });\r\n\r\n  // Поиск нулевых пересечений\r\n  const { t0, y0 } = findZeroCrossings(t, interf);\r\n  console.log(`Найдено нулевых пересечений: ${t0.length}`);\r\n\r\n  // Фильтрация близких точек\r\n  const { filteredT0, filteredY0 } = filterClosePoints(t0, y0, 100e-9);\r\n  console.log(`После фильтрации: ${filteredT0.length}`);\r\n\r\n  // Расчет производной\r\n  const { u_interf, dudt_interf } = calculateDerivative(filteredT0);\r\n\r\n  return {\r\n    t,\r\n    tenz,\r\n    interf,\r\n    t0: filteredT0,\r\n    y0: filteredY0,\r\n    u_interf,\r\n    dudt_interf,\r\n  };\r\n};\r\n\r\nconst findZeroCrossings = (t, interf) => {\r\n  const t0 = [];\r\n  const y0 = [];\r\n\r\n  for (let i = 1; i < interf.length; i++) {\r\n    const y1 = interf[i - 1];\r\n    const y2 = interf[i];\r\n\r\n    // Проверяем пересечение нуля\r\n    if ((y1 <= 0 && y2 > 0) || (y1 >= 0 && y2 < 0)) {\r\n      const x1 = t[i - 1];\r\n      const x2 = t[i];\r\n\r\n      // Линейная интерполяция для точного определения точки пересечения\r\n      if (y2 !== y1) {\r\n        const t_zero = x1 - (y1 * (x2 - x1)) / (y2 - y1);\r\n        t0.push(t_zero);\r\n        y0.push(0);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { t0, y0 };\r\n};\r\n\r\nconst filterClosePoints = (t0, y0, minDistance) => {\r\n  if (t0.length <= 1) {\r\n    return { filteredT0: t0, filteredY0: y0 };\r\n  }\r\n\r\n  let filteredT0 = [...t0];\r\n  let filteredY0 = [...y0];\r\n\r\n  // Многократная фильтрация (k < 10 как в оригинале)\r\n  for (let k = 0; k < 10; k++) {\r\n    const newT0 = [filteredT0[0]];\r\n    const newY0 = [filteredY0[0]];\r\n\r\n    for (let i = 1; i < filteredT0.length; i++) {\r\n      if (filteredT0[i] - newT0[newT0.length - 1] >= minDistance) {\r\n        newT0.push(filteredT0[i]);\r\n        newY0.push(filteredY0[i]);\r\n      }\r\n    }\r\n\r\n    // Если количество точек не изменилось, выходим\r\n    if (newT0.length === filteredT0.length) break;\r\n\r\n    filteredT0 = newT0;\r\n    filteredY0 = newY0;\r\n  }\r\n\r\n  return { filteredT0, filteredY0 };\r\n};\r\n\r\nconst calculateDerivative = (t0) => {\r\n  const u_interf = [];\r\n  const dudt_interf = [];\r\n\r\n  for (let i = 0; i < t0.length; i++) {\r\n    if (i === 0) {\r\n      u_interf[i] = (0.63 / 4) * 1e-6;\r\n      dudt_interf[i] = 0;\r\n    } else {\r\n      u_interf[i] = u_interf[i - 1] + (0.63 / 4) * 1e-6;\r\n      const du_interf = u_interf[i] - u_interf[i - 1];\r\n      const dt_interf = t0[i] - t0[i - 1];\r\n      dudt_interf[i] = dt_interf !== 0 ? du_interf / dt_interf : 0;\r\n    }\r\n  }\r\n\r\n  return { u_interf, dudt_interf };\r\n};\r\n\r\nexport const generateChartData = (results) => {\r\n  const { t, tenz, interf, t0, dudt_interf } = results;\r\n\r\n  // Ограничиваем количество точек для производительности\r\n  const step = Math.max(1, Math.floor(t.length / 2000));\r\n\r\n  const limitedT = [];\r\n  const limitedTenz = [];\r\n  const limitedInterf = [];\r\n\r\n  for (let i = 0; i < t.length; i += step) {\r\n    limitedT.push(t[i]);\r\n    limitedTenz.push(tenz[i]);\r\n    limitedInterf.push(interf[i]);\r\n  }\r\n\r\n  // Подготавливаем данные для графиков\r\n  const chartData = {\r\n    original: [\r\n      {\r\n        label: \"Тензометрический сигнал (CH1)\",\r\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedTenz[idx] })),\r\n        borderColor: \"rgb(255, 99, 132)\",\r\n        backgroundColor: \"rgba(255, 99, 132, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n      {\r\n        label: \"Интерферометрический сигнал (CH3)\",\r\n        data: limitedT.map((time, idx) => ({ x: time, y: limitedInterf[idx] })),\r\n        borderColor: \"rgb(54, 162, 235)\",\r\n        backgroundColor: \"rgba(54, 162, 235, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n    ],\r\n    processed: [\r\n      {\r\n        label: \"Производная интерферометрического сигнала\",\r\n        data: t0.map((time, idx) => ({\r\n          x: time - 51.5e-6, // коррекция времени\r\n          y: dudt_interf[idx],\r\n        })),\r\n        borderColor: \"rgb(75, 192, 192)\",\r\n        backgroundColor: \"rgba(75, 192, 192, 0.1)\",\r\n        borderWidth: 2,\r\n        pointRadius: 2,\r\n        showLine: true,\r\n      },\r\n      {\r\n        label: \"Скорректированный тензосигнал\",\r\n        data: limitedT.map((time, idx) => ({\r\n          x: time + 50e-6, // коррекция времени\r\n          y: -limitedTenz[idx] * 5000 + 0.38, // преобразование\r\n        })),\r\n        borderColor: \"rgb(153, 102, 255)\",\r\n        backgroundColor: \"rgba(153, 102, 255, 0.1)\",\r\n        borderWidth: 1,\r\n        tension: 0.1,\r\n      },\r\n    ],\r\n  };\r\n\r\n  console.log(\"Данные для графиков подготовлены\");\r\n\r\n  return chartData;\r\n};\r\n"],"mappings":"AAAA,OAAO,MAAMA,cAAc,GAAIC,IAAI,IAAK;EACtC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAE/BD,MAAM,CAACE,MAAM,GAAIC,CAAC,IAAK;MACrB,IAAI;QACF,MAAMC,OAAO,GAAGD,CAAC,CAACE,MAAM,CAACC,MAAM;QAC/B,MAAMC,OAAO,GAAGC,QAAQ,CAACJ,OAAO,CAAC;QACjCN,OAAO,CAACS,OAAO,CAAC;MAClB,CAAC,CAAC,OAAOE,KAAK,EAAE;QACdV,MAAM,CAACU,KAAK,CAAC;MACf;IACF,CAAC;IAEDT,MAAM,CAACU,OAAO,GAAG,MAAMX,MAAM,CAAC,IAAIY,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC/DX,MAAM,CAACY,UAAU,CAAChB,IAAI,CAAC;EACzB,CAAC,CAAC;AACJ,CAAC;AAED,MAAMY,QAAQ,GAAIJ,OAAO,IAAK;EAC5B,MAAMS,KAAK,GAAGT,OAAO,CAACU,KAAK,CAAC,IAAI,CAAC;EACjC,MAAMC,CAAC,GAAG,EAAE;EACZ,MAAMC,IAAI,GAAG,EAAE,CAAC,CAAC;EACjB,MAAMC,MAAM,GAAG,EAAE,CAAC,CAAC;;EAEnB,IAAIC,WAAW,GAAG,KAAK;EACvB,IAAIC,SAAS,GAAG,CAAC;EAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,MAAME,IAAI,GAAGT,KAAK,CAACO,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;;IAE5B;IACA,IAAI,CAACD,IAAI,EAAE;;IAEX;IACA,IAAIA,IAAI,CAACE,UAAU,CAAC,WAAW,CAAC,EAAE;MAChCN,WAAW,GAAG,IAAI;MAClB;IACF;;IAEA;IACA,IAAIA,WAAW,EAAE;MACfC,SAAS,EAAE;;MAEX;MACA,IAAIA,SAAS,GAAG,IAAI,EAAE;MACtB,IAAIA,SAAS,GAAG,KAAK,EAAE;MAEvB,MAAMM,MAAM,GAAGH,IAAI,CAACR,KAAK,CAAC,GAAG,CAAC;MAE9B,IAAIW,MAAM,CAACJ,MAAM,IAAI,CAAC,EAAE;QACtB,MAAMK,OAAO,GAAGC,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvC,MAAMG,MAAM,GAAGD,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,MAAMI,MAAM,GAAGF,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEtC,IAAI,CAACK,KAAK,CAACJ,OAAO,CAAC,IAAI,CAACI,KAAK,CAACF,MAAM,CAAC,IAAI,CAACE,KAAK,CAACD,MAAM,CAAC,EAAE;UACvDd,CAAC,CAACgB,IAAI,CAACL,OAAO,CAAC;UACf;UACAV,IAAI,CAACe,IAAI,CAACH,MAAM,GAAG,OAAO,GAAG,IAAI,CAAC;UAClC;UACAX,MAAM,CAACc,IAAI,CAACF,MAAM,GAAG,IAAI,CAAC;QAC5B;MACF;IACF;EACF;EAEAG,OAAO,CAACC,GAAG,CACT,uBAAuBlB,CAAC,CAACM,MAAM,UAAUL,IAAI,CAACK,MAAM,YAAYJ,MAAM,CAACI,MAAM,EAC/E,CAAC;EACDW,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAE;IAC9BlB,CAAC,EAAEA,CAAC,CAACmB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IAChBlB,IAAI,EAAEA,IAAI,CAACkB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IACtBjB,MAAM,EAAEA,MAAM,CAACiB,KAAK,CAAC,CAAC,EAAE,CAAC;EAC3B,CAAC,CAAC;;EAEF;EACA,MAAM;IAAEC,EAAE;IAAEC;EAAG,CAAC,GAAGC,iBAAiB,CAACtB,CAAC,EAAEE,MAAM,CAAC;EAC/Ce,OAAO,CAACC,GAAG,CAAC,gCAAgCE,EAAE,CAACd,MAAM,EAAE,CAAC;;EAExD;EACA,MAAM;IAAEiB,UAAU;IAAEC;EAAW,CAAC,GAAGC,iBAAiB,CAACL,EAAE,EAAEC,EAAE,EAAE,MAAM,CAAC;EACpEJ,OAAO,CAACC,GAAG,CAAC,qBAAqBK,UAAU,CAACjB,MAAM,EAAE,CAAC;;EAErD;EACA,MAAM;IAAEoB,QAAQ;IAAEC;EAAY,CAAC,GAAGC,mBAAmB,CAACL,UAAU,CAAC;EAEjE,OAAO;IACLvB,CAAC;IACDC,IAAI;IACJC,MAAM;IACNkB,EAAE,EAAEG,UAAU;IACdF,EAAE,EAAEG,UAAU;IACdE,QAAQ;IACRC;EACF,CAAC;AACH,CAAC;AAED,MAAML,iBAAiB,GAAGA,CAACtB,CAAC,EAAEE,MAAM,KAAK;EACvC,MAAMkB,EAAE,GAAG,EAAE;EACb,MAAMC,EAAE,GAAG,EAAE;EAEb,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,MAAMwB,EAAE,GAAG3B,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC;IACxB,MAAMyB,EAAE,GAAG5B,MAAM,CAACG,CAAC,CAAC;;IAEpB;IACA,IAAKwB,EAAE,IAAI,CAAC,IAAIC,EAAE,GAAG,CAAC,IAAMD,EAAE,IAAI,CAAC,IAAIC,EAAE,GAAG,CAAE,EAAE;MAC9C,MAAMC,EAAE,GAAG/B,CAAC,CAACK,CAAC,GAAG,CAAC,CAAC;MACnB,MAAM2B,EAAE,GAAGhC,CAAC,CAACK,CAAC,CAAC;;MAEf;MACA,IAAIyB,EAAE,KAAKD,EAAE,EAAE;QACb,MAAMI,MAAM,GAAGF,EAAE,GAAIF,EAAE,IAAIG,EAAE,GAAGD,EAAE,CAAC,IAAKD,EAAE,GAAGD,EAAE,CAAC;QAChDT,EAAE,CAACJ,IAAI,CAACiB,MAAM,CAAC;QACfZ,EAAE,CAACL,IAAI,CAAC,CAAC,CAAC;MACZ;IACF;EACF;EAEA,OAAO;IAAEI,EAAE;IAAEC;EAAG,CAAC;AACnB,CAAC;AAED,MAAMI,iBAAiB,GAAGA,CAACL,EAAE,EAAEC,EAAE,EAAEa,WAAW,KAAK;EACjD,IAAId,EAAE,CAACd,MAAM,IAAI,CAAC,EAAE;IAClB,OAAO;MAAEiB,UAAU,EAAEH,EAAE;MAAEI,UAAU,EAAEH;IAAG,CAAC;EAC3C;EAEA,IAAIE,UAAU,GAAG,CAAC,GAAGH,EAAE,CAAC;EACxB,IAAII,UAAU,GAAG,CAAC,GAAGH,EAAE,CAAC;;EAExB;EACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3B,MAAMC,KAAK,GAAG,CAACb,UAAU,CAAC,CAAC,CAAC,CAAC;IAC7B,MAAMc,KAAK,GAAG,CAACb,UAAU,CAAC,CAAC,CAAC,CAAC;IAE7B,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,UAAU,CAACjB,MAAM,EAAED,CAAC,EAAE,EAAE;MAC1C,IAAIkB,UAAU,CAAClB,CAAC,CAAC,GAAG+B,KAAK,CAACA,KAAK,CAAC9B,MAAM,GAAG,CAAC,CAAC,IAAI4B,WAAW,EAAE;QAC1DE,KAAK,CAACpB,IAAI,CAACO,UAAU,CAAClB,CAAC,CAAC,CAAC;QACzBgC,KAAK,CAACrB,IAAI,CAACQ,UAAU,CAACnB,CAAC,CAAC,CAAC;MAC3B;IACF;;IAEA;IACA,IAAI+B,KAAK,CAAC9B,MAAM,KAAKiB,UAAU,CAACjB,MAAM,EAAE;IAExCiB,UAAU,GAAGa,KAAK;IAClBZ,UAAU,GAAGa,KAAK;EACpB;EAEA,OAAO;IAAEd,UAAU;IAAEC;EAAW,CAAC;AACnC,CAAC;AAED,MAAMI,mBAAmB,GAAIR,EAAE,IAAK;EAClC,MAAMM,QAAQ,GAAG,EAAE;EACnB,MAAMC,WAAW,GAAG,EAAE;EAEtB,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,EAAE,CAACd,MAAM,EAAED,CAAC,EAAE,EAAE;IAClC,IAAIA,CAAC,KAAK,CAAC,EAAE;MACXqB,QAAQ,CAACrB,CAAC,CAAC,GAAI,IAAI,GAAG,CAAC,GAAI,IAAI;MAC/BsB,WAAW,CAACtB,CAAC,CAAC,GAAG,CAAC;IACpB,CAAC,MAAM;MACLqB,QAAQ,CAACrB,CAAC,CAAC,GAAGqB,QAAQ,CAACrB,CAAC,GAAG,CAAC,CAAC,GAAI,IAAI,GAAG,CAAC,GAAI,IAAI;MACjD,MAAMiC,SAAS,GAAGZ,QAAQ,CAACrB,CAAC,CAAC,GAAGqB,QAAQ,CAACrB,CAAC,GAAG,CAAC,CAAC;MAC/C,MAAMkC,SAAS,GAAGnB,EAAE,CAACf,CAAC,CAAC,GAAGe,EAAE,CAACf,CAAC,GAAG,CAAC,CAAC;MACnCsB,WAAW,CAACtB,CAAC,CAAC,GAAGkC,SAAS,KAAK,CAAC,GAAGD,SAAS,GAAGC,SAAS,GAAG,CAAC;IAC9D;EACF;EAEA,OAAO;IAAEb,QAAQ;IAAEC;EAAY,CAAC;AAClC,CAAC;AAED,OAAO,MAAMa,iBAAiB,GAAIhD,OAAO,IAAK;EAC5C,MAAM;IAAEQ,CAAC;IAAEC,IAAI;IAAEC,MAAM;IAAEkB,EAAE;IAAEO;EAAY,CAAC,GAAGnC,OAAO;;EAEpD;EACA,MAAMiD,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,KAAK,CAAC5C,CAAC,CAACM,MAAM,GAAG,IAAI,CAAC,CAAC;EAErD,MAAMuC,QAAQ,GAAG,EAAE;EACnB,MAAMC,WAAW,GAAG,EAAE;EACtB,MAAMC,aAAa,GAAG,EAAE;EAExB,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,CAACM,MAAM,EAAED,CAAC,IAAIoC,IAAI,EAAE;IACvCI,QAAQ,CAAC7B,IAAI,CAAChB,CAAC,CAACK,CAAC,CAAC,CAAC;IACnByC,WAAW,CAAC9B,IAAI,CAACf,IAAI,CAACI,CAAC,CAAC,CAAC;IACzB0C,aAAa,CAAC/B,IAAI,CAACd,MAAM,CAACG,CAAC,CAAC,CAAC;EAC/B;;EAEA;EACA,MAAM2C,SAAS,GAAG;IAChBC,QAAQ,EAAE,CACR;MACEC,KAAK,EAAE,+BAA+B;MACtCC,IAAI,EAAEN,QAAQ,CAACO,GAAG,CAAC,CAACC,IAAI,EAAEC,GAAG,MAAM;QAAEC,CAAC,EAAEF,IAAI;QAAEG,CAAC,EAAEV,WAAW,CAACQ,GAAG;MAAE,CAAC,CAAC,CAAC;MACrEG,WAAW,EAAE,mBAAmB;MAChCC,eAAe,EAAE,yBAAyB;MAC1CC,WAAW,EAAE,CAAC;MACdC,OAAO,EAAE;IACX,CAAC,EACD;MACEV,KAAK,EAAE,mCAAmC;MAC1CC,IAAI,EAAEN,QAAQ,CAACO,GAAG,CAAC,CAACC,IAAI,EAAEC,GAAG,MAAM;QAAEC,CAAC,EAAEF,IAAI;QAAEG,CAAC,EAAET,aAAa,CAACO,GAAG;MAAE,CAAC,CAAC,CAAC;MACvEG,WAAW,EAAE,mBAAmB;MAChCC,eAAe,EAAE,yBAAyB;MAC1CC,WAAW,EAAE,CAAC;MACdC,OAAO,EAAE;IACX,CAAC,CACF;IACDC,SAAS,EAAE,CACT;MACEX,KAAK,EAAE,2CAA2C;MAClDC,IAAI,EAAE/B,EAAE,CAACgC,GAAG,CAAC,CAACC,IAAI,EAAEC,GAAG,MAAM;QAC3BC,CAAC,EAAEF,IAAI,GAAG,OAAO;QAAE;QACnBG,CAAC,EAAE7B,WAAW,CAAC2B,GAAG;MACpB,CAAC,CAAC,CAAC;MACHG,WAAW,EAAE,mBAAmB;MAChCC,eAAe,EAAE,yBAAyB;MAC1CC,WAAW,EAAE,CAAC;MACdG,WAAW,EAAE,CAAC;MACdC,QAAQ,EAAE;IACZ,CAAC,EACD;MACEb,KAAK,EAAE,+BAA+B;MACtCC,IAAI,EAAEN,QAAQ,CAACO,GAAG,CAAC,CAACC,IAAI,EAAEC,GAAG,MAAM;QACjCC,CAAC,EAAEF,IAAI,GAAG,KAAK;QAAE;QACjBG,CAAC,EAAE,CAACV,WAAW,CAACQ,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAE;MACtC,CAAC,CAAC,CAAC;MACHG,WAAW,EAAE,oBAAoB;MACjCC,eAAe,EAAE,0BAA0B;MAC3CC,WAAW,EAAE,CAAC;MACdC,OAAO,EAAE;IACX,CAAC;EAEL,CAAC;EAED3C,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;EAE/C,OAAO8B,SAAS;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}